<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Refureku: rfk::Method Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="rfk-compact-logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Refureku<span id="projectnumber">&#160;v2.1.2</span>
   </div>
   <div id="projectbrief">C++17 runtime reflection library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrfk_1_1_method.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrfk_1_1_method-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rfk::Method Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for rfk::Method:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrfk_1_1_method.png" usemap="#rfk::Method_map" alt=""/>
  <map id="rfk::Method_map" name="rfk::Method_map">
<area href="classrfk_1_1_method_base.html" alt="rfk::MethodBase" shape="rect" coords="0,112,110,136"/>
<area href="classrfk_1_1_function_base.html" alt="rfk::FunctionBase" shape="rect" coords="0,56,110,80"/>
<area href="classrfk_1_1_entity.html" alt="rfk::Entity" shape="rect" coords="0,0,110,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a88fae752fc49573487f484882801d266"><td class="memItemLeft" align="right" valign="top"><a id="a88fae752fc49573487f484882801d266" name="a88fae752fc49573487f484882801d266"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Method</b> (char const *name, std::size_t id, <a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;returnType, <a class="el" href="classrfk_1_1_i_callable.html">ICallable</a> *internalMethod, <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a> flags, <a class="el" href="classrfk_1_1_entity.html">Entity</a> const *outerEntity) noexcept</td></tr>
<tr class="separator:a88fae752fc49573487f484882801d266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb061a46d94ef462ae698afbf3698315"><td class="memItemLeft" align="right" valign="top"><a id="abb061a46d94ef462ae698afbf3698315" name="abb061a46d94ef462ae698afbf3698315"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Method</b> (<a class="el" href="classrfk_1_1_method.html">Method</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:abb061a46d94ef462ae698afbf3698315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fccea5413d86d922fb65fd42f3ca5c4"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType  = void, typename CallerType , typename... ArgTypes, typename  = std::enable_if_t&lt;!std::is_const_v&lt;CallerType&gt;&gt;&gt; </td></tr>
<tr class="memitem:a1fccea5413d86d922fb65fd42f3ca5c4"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method.html#a1fccea5413d86d922fb65fd42f3ca5c4">invoke</a> (CallerType &amp;caller, ArgTypes &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a1fccea5413d86d922fb65fd42f3ca5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the function with the forwarded argument(s) if any, and return the result. Providing bad return type / parameters is undefined behaviour. <b>WARNING</b>: Template type deduction might forward wrong types to the function (int instead of int8_t or char* instead of std::string for example), so it is recommended to explicitly specify all template types when calling the function.  <a href="classrfk_1_1_method.html#a1fccea5413d86d922fb65fd42f3ca5c4">More...</a><br /></td></tr>
<tr class="separator:a1fccea5413d86d922fb65fd42f3ca5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c5732e1d8aa4f284448d5727b15fe2"><td class="memTemplParams" colspan="2"><a id="a41c5732e1d8aa4f284448d5727b15fe2" name="a41c5732e1d8aa4f284448d5727b15fe2"></a>
template&lt;typename ReturnType  = void, typename CallerType , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a41c5732e1d8aa4f284448d5727b15fe2"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invoke</b> (CallerType const &amp;caller, ArgTypes &amp;&amp;... args) const</td></tr>
<tr class="separator:a41c5732e1d8aa4f284448d5727b15fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777fa1a63dabef8f7a7276c254246a46"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType  = void, typename CallerType , typename... ArgTypes, typename  = std::enable_if_t&lt;!std::is_const_v&lt;CallerType&gt;&gt;&gt; </td></tr>
<tr class="memitem:a777fa1a63dabef8f7a7276c254246a46"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method.html#a777fa1a63dabef8f7a7276c254246a46">checkedInvoke</a> (CallerType &amp;caller, ArgTypes &amp;&amp;... args) const</td></tr>
<tr class="memdesc:a777fa1a63dabef8f7a7276c254246a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the function with the forwarded argument(s) if any, and return the result. The return type and arguments types will be strictly checked before calling the function. If there is any mismatch, <a class="el" href="classrfk_1_1_arg_count_mismatch.html">ArgCountMismatch</a>, <a class="el" href="classrfk_1_1_arg_type_mismatch.html">ArgTypeMismatch</a> or <a class="el" href="classrfk_1_1_return_type_mismatch.html">ReturnTypeMismatch</a> will be thrown. <b>WARNING 1</b>: Unreflected archetypes can't be compared, so they will pass through the type checks. <b>WARNING 2</b>: Template type deduction might forward wrong types to the function (int instead of int8_t or char* instead of std::string for example), so it is recommended to explicitly specify all template types when calling the function.  <a href="classrfk_1_1_method.html#a777fa1a63dabef8f7a7276c254246a46">More...</a><br /></td></tr>
<tr class="separator:a777fa1a63dabef8f7a7276c254246a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1f56410e3afa4ece6b7f0ca5a1d209"><td class="memTemplParams" colspan="2"><a id="a1f1f56410e3afa4ece6b7f0ca5a1d209" name="a1f1f56410e3afa4ece6b7f0ca5a1d209"></a>
template&lt;typename ReturnType  = void, typename CallerType , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a1f1f56410e3afa4ece6b7f0ca5a1d209"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>checkedInvoke</b> (CallerType const &amp;caller, ArgTypes &amp;&amp;... args) const</td></tr>
<tr class="separator:a1f1f56410e3afa4ece6b7f0ca5a1d209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2547ee0b4c068970059c9192ec50933"><td class="memItemLeft" align="right" valign="top"><a id="ab2547ee0b4c068970059c9192ec50933" name="ab2547ee0b4c068970059c9192ec50933"></a>
REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><b>inheritBaseMethodProperties</b> () noexcept</td></tr>
<tr class="memdesc:ab2547ee0b4c068970059c9192ec50933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit from the properties this method overrides. If the method is not an override, this method does nothing. <br /></td></tr>
<tr class="separator:ab2547ee0b4c068970059c9192ec50933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrfk_1_1_method_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrfk_1_1_method_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrfk_1_1_method_base.html">rfk::MethodBase</a></td></tr>
<tr class="memitem:a15ac92b9bad254c23f81627d77da3fb1 inherit pub_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#a15ac92b9bad254c23f81627d77da3fb1">hasSameSignature</a> (<a class="el" href="classrfk_1_1_method_base.html">MethodBase</a> const &amp;other) const noexcept</td></tr>
<tr class="memdesc:a15ac92b9bad254c23f81627d77da3fb1 inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that another function has the same prototype as this function. <b>WARNING:</b> Non reflected type archetypes are considered equal since their archetype is nullptr.  <a href="classrfk_1_1_method_base.html#a15ac92b9bad254c23f81627d77da3fb1">More...</a><br /></td></tr>
<tr class="separator:a15ac92b9bad254c23f81627d77da3fb1 inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dd506197749fcd6f5243247fa76a63 inherit pub_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#a26dd506197749fcd6f5243247fa76a63">isStatic</a> () const noexcept</td></tr>
<tr class="memdesc:a26dd506197749fcd6f5243247fa76a63 inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this method is static.  <a href="classrfk_1_1_method_base.html#a26dd506197749fcd6f5243247fa76a63">More...</a><br /></td></tr>
<tr class="separator:a26dd506197749fcd6f5243247fa76a63 inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ea5e396030299b528fde557ed88623 inherit pub_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#ab7ea5e396030299b528fde557ed88623">isInline</a> () const noexcept</td></tr>
<tr class="memdesc:ab7ea5e396030299b528fde557ed88623 inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this method is marked with the inline qualifier or defined in the header file.  <a href="classrfk_1_1_method_base.html#ab7ea5e396030299b528fde557ed88623">More...</a><br /></td></tr>
<tr class="separator:ab7ea5e396030299b528fde557ed88623 inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa99f8bd2d85a7106fed4ac7f2c719a inherit pub_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#a7aa99f8bd2d85a7106fed4ac7f2c719a">isVirtual</a> () const noexcept</td></tr>
<tr class="memdesc:a7aa99f8bd2d85a7106fed4ac7f2c719a inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this method is virtual.  <a href="classrfk_1_1_method_base.html#a7aa99f8bd2d85a7106fed4ac7f2c719a">More...</a><br /></td></tr>
<tr class="separator:a7aa99f8bd2d85a7106fed4ac7f2c719a inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00643f6db5631f731a9c29add3ec9b88 inherit pub_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#a00643f6db5631f731a9c29add3ec9b88">isPureVirtual</a> () const noexcept</td></tr>
<tr class="memdesc:a00643f6db5631f731a9c29add3ec9b88 inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this method is pure virtual.  <a href="classrfk_1_1_method_base.html#a00643f6db5631f731a9c29add3ec9b88">More...</a><br /></td></tr>
<tr class="separator:a00643f6db5631f731a9c29add3ec9b88 inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15306f7f11355627becc2ddc67207741 inherit pub_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#a15306f7f11355627becc2ddc67207741">isOverride</a> () const noexcept</td></tr>
<tr class="memdesc:a15306f7f11355627becc2ddc67207741 inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this method is override-qualified. <b>WARNING:</b> An overriding method not explicitly qualified with the override keyword will return false.  <a href="classrfk_1_1_method_base.html#a15306f7f11355627becc2ddc67207741">More...</a><br /></td></tr>
<tr class="separator:a15306f7f11355627becc2ddc67207741 inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d16a60a86b48455589ef5b55951831 inherit pub_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#a75d16a60a86b48455589ef5b55951831">isFinal</a> () const noexcept</td></tr>
<tr class="memdesc:a75d16a60a86b48455589ef5b55951831 inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this method is final-qualified. <b>WARNING:</b> An override method part of a final class will return false.  <a href="classrfk_1_1_method_base.html#a75d16a60a86b48455589ef5b55951831">More...</a><br /></td></tr>
<tr class="separator:a75d16a60a86b48455589ef5b55951831 inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245d86d1b0f4589ff24fe1dfe2cb648e inherit pub_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#a245d86d1b0f4589ff24fe1dfe2cb648e">isConst</a> () const noexcept</td></tr>
<tr class="memdesc:a245d86d1b0f4589ff24fe1dfe2cb648e inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this method is const-qualified.  <a href="classrfk_1_1_method_base.html#a245d86d1b0f4589ff24fe1dfe2cb648e">More...</a><br /></td></tr>
<tr class="separator:a245d86d1b0f4589ff24fe1dfe2cb648e inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aa5961b3b7ed3ca6f6e05dace23fe0 inherit pub_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="namespacerfk.html#aede2763da2d837a7ee63b105269d5f6e">EMethodFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#af1aa5961b3b7ed3ca6f6e05dace23fe0">getFlags</a> () const noexcept</td></tr>
<tr class="memdesc:af1aa5961b3b7ed3ca6f6e05dace23fe0 inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flags qualifying this method.  <a href="classrfk_1_1_method_base.html#af1aa5961b3b7ed3ca6f6e05dace23fe0">More...</a><br /></td></tr>
<tr class="separator:af1aa5961b3b7ed3ca6f6e05dace23fe0 inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84db76bffdaac6ff5067515722f8075 inherit pub_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API EAccessSpecifier&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#ac84db76bffdaac6ff5067515722f8075">getAccess</a> () const noexcept</td></tr>
<tr class="memdesc:ac84db76bffdaac6ff5067515722f8075 inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the access specifier of this method in its owner struct/class.  <a href="classrfk_1_1_method_base.html#ac84db76bffdaac6ff5067515722f8075">More...</a><br /></td></tr>
<tr class="separator:ac84db76bffdaac6ff5067515722f8075 inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ba1ac83a467c03ddb15a27dfddb4cd inherit pub_methods_classrfk_1_1_method_base"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:ad6ba1ac83a467c03ddb15a27dfddb4cd inherit pub_methods_classrfk_1_1_method_base"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#ad6ba1ac83a467c03ddb15a27dfddb4cd">hasSameSignature</a> () const noexcept</td></tr>
<tr class="memdesc:ad6ba1ac83a467c03ddb15a27dfddb4cd inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether 2 functions have the same signature. Non reflected types are compared equal, so NonReflectedType1 and NonReflectedType2 are considered equal since their archetype is the same.  <a href="classrfk_1_1_method_base.html#ad6ba1ac83a467c03ddb15a27dfddb4cd">More...</a><br /></td></tr>
<tr class="separator:ad6ba1ac83a467c03ddb15a27dfddb4cd inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cf4fc4651757271ca1722dff642593 inherit pub_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_method_base.html#ab4cf4fc4651757271ca1722dff642593">hasSameSignature</a> (<a class="el" href="classrfk_1_1_function_base.html">FunctionBase</a> const &amp;other) const noexcept</td></tr>
<tr class="memdesc:ab4cf4fc4651757271ca1722dff642593 inherit pub_methods_classrfk_1_1_method_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that another function has the same prototype as this function. Non reflected types are compared equal, so NonReflectedType1 and NonReflectedType2 are considered equal since their archetype is the same.  <a href="classrfk_1_1_method_base.html#ab4cf4fc4651757271ca1722dff642593">More...</a><br /></td></tr>
<tr class="separator:ab4cf4fc4651757271ca1722dff642593 inherit pub_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrfk_1_1_function_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrfk_1_1_function_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrfk_1_1_function_base.html">rfk::FunctionBase</a></td></tr>
<tr class="memitem:ad6ba1ac83a467c03ddb15a27dfddb4cd inherit pub_methods_classrfk_1_1_function_base"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename... ArgTypes&gt; </td></tr>
<tr class="memitem:ad6ba1ac83a467c03ddb15a27dfddb4cd inherit pub_methods_classrfk_1_1_function_base"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#ad6ba1ac83a467c03ddb15a27dfddb4cd">hasSameSignature</a> () const noexcept</td></tr>
<tr class="memdesc:ad6ba1ac83a467c03ddb15a27dfddb4cd inherit pub_methods_classrfk_1_1_function_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether 2 functions have the same signature. Non reflected types are compared equal, so NonReflectedType1 and NonReflectedType2 are considered equal since their archetype is the same.  <a href="classrfk_1_1_function_base.html#ad6ba1ac83a467c03ddb15a27dfddb4cd">More...</a><br /></td></tr>
<tr class="separator:ad6ba1ac83a467c03ddb15a27dfddb4cd inherit pub_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cf4fc4651757271ca1722dff642593 inherit pub_methods_classrfk_1_1_function_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#ab4cf4fc4651757271ca1722dff642593">hasSameSignature</a> (<a class="el" href="classrfk_1_1_function_base.html">FunctionBase</a> const &amp;other) const noexcept</td></tr>
<tr class="memdesc:ab4cf4fc4651757271ca1722dff642593 inherit pub_methods_classrfk_1_1_function_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that another function has the same prototype as this function. Non reflected types are compared equal, so NonReflectedType1 and NonReflectedType2 are considered equal since their archetype is the same.  <a href="classrfk_1_1_function_base.html#ab4cf4fc4651757271ca1722dff642593">More...</a><br /></td></tr>
<tr class="separator:ab4cf4fc4651757271ca1722dff642593 inherit pub_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be119a00e22e0a5e2f9132f4f7c24b1 inherit pub_methods_classrfk_1_1_function_base"><td class="memTemplParams" colspan="2">template&lt;typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a5be119a00e22e0a5e2f9132f4f7c24b1 inherit pub_methods_classrfk_1_1_function_base"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#a5be119a00e22e0a5e2f9132f4f7c24b1">hasSameParameters</a> () const noexcept</td></tr>
<tr class="separator:a5be119a00e22e0a5e2f9132f4f7c24b1 inherit pub_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fea621303041e36e1a1ca6e49924be6 inherit pub_methods_classrfk_1_1_function_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#a6fea621303041e36e1a1ca6e49924be6">getReturnType</a> () const noexcept</td></tr>
<tr class="memdesc:a6fea621303041e36e1a1ca6e49924be6 inherit pub_methods_classrfk_1_1_function_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the return type of this function.  <a href="classrfk_1_1_function_base.html#a6fea621303041e36e1a1ca6e49924be6">More...</a><br /></td></tr>
<tr class="separator:a6fea621303041e36e1a1ca6e49924be6 inherit pub_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad636c2135505576d4e172809b4bea77d inherit pub_methods_classrfk_1_1_function_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_function_parameter.html">FunctionParameter</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#ad636c2135505576d4e172809b4bea77d">getParameterAt</a> (std::size_t index) const noexcept</td></tr>
<tr class="memdesc:ad636c2135505576d4e172809b4bea77d inherit pub_methods_classrfk_1_1_function_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the parameter at the given index. If index is greater or equal to the parameters count, the behaviour is undefined.  <a href="classrfk_1_1_function_base.html#ad636c2135505576d4e172809b4bea77d">More...</a><br /></td></tr>
<tr class="separator:ad636c2135505576d4e172809b4bea77d inherit pub_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae407b16a382f88da360e50b71d3114d9 inherit pub_methods_classrfk_1_1_function_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#ae407b16a382f88da360e50b71d3114d9">getParametersCount</a> () const noexcept</td></tr>
<tr class="memdesc:ae407b16a382f88da360e50b71d3114d9 inherit pub_methods_classrfk_1_1_function_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of parameters of this function.  <a href="classrfk_1_1_function_base.html#ae407b16a382f88da360e50b71d3114d9">More...</a><br /></td></tr>
<tr class="separator:ae407b16a382f88da360e50b71d3114d9 inherit pub_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3992fefebf9f508bfd706b1b3e7ddeb1 inherit pub_methods_classrfk_1_1_function_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_i_callable.html">ICallable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#a3992fefebf9f508bfd706b1b3e7ddeb1">getInternalFunction</a> () const noexcept</td></tr>
<tr class="memdesc:a3992fefebf9f508bfd706b1b3e7ddeb1 inherit pub_methods_classrfk_1_1_function_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal function handled by this object.  <a href="classrfk_1_1_function_base.html#a3992fefebf9f508bfd706b1b3e7ddeb1">More...</a><br /></td></tr>
<tr class="separator:a3992fefebf9f508bfd706b1b3e7ddeb1 inherit pub_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56388eee567de247a93fa424851782a8 inherit pub_methods_classrfk_1_1_function_base"><td class="memItemLeft" align="right" valign="top">REFUREKU_API <a class="el" href="classrfk_1_1_function_parameter.html">FunctionParameter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#a56388eee567de247a93fa424851782a8">addParameter</a> (char const *name, std::size_t id, <a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;type) noexcept</td></tr>
<tr class="memdesc:a56388eee567de247a93fa424851782a8 inherit pub_methods_classrfk_1_1_function_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a parameter to the function.  <a href="classrfk_1_1_function_base.html#a56388eee567de247a93fa424851782a8">More...</a><br /></td></tr>
<tr class="separator:a56388eee567de247a93fa424851782a8 inherit pub_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b474932498b2e847270b61c81eb4f9d inherit pub_methods_classrfk_1_1_function_base"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#a7b474932498b2e847270b61c81eb4f9d">setParametersCapacity</a> (std::size_t capacity) noexcept</td></tr>
<tr class="memdesc:a7b474932498b2e847270b61c81eb4f9d inherit pub_methods_classrfk_1_1_function_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of parameters for this function. Useful to avoid reallocations when adding a lot of parameters. If the number of parameters is already &gt;= to the provided count, this method has no effect.  <a href="classrfk_1_1_function_base.html#a7b474932498b2e847270b61c81eb4f9d">More...</a><br /></td></tr>
<tr class="separator:a7b474932498b2e847270b61c81eb4f9d inherit pub_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrfk_1_1_entity"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrfk_1_1_entity')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrfk_1_1_entity.html">rfk::Entity</a></td></tr>
<tr class="memitem:a092dbecc208629377670a6afc05af06d inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a092dbecc208629377670a6afc05af06d" name="a092dbecc208629377670a6afc05af06d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Entity</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;)=delete</td></tr>
<tr class="separator:a092dbecc208629377670a6afc05af06d inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b78b5d1f76408794f38bf0f8e7310b1 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a0b78b5d1f76408794f38bf0f8e7310b1">getPropertyAt</a> (std::size_t propertyIndex) const noexcept</td></tr>
<tr class="memdesc:a0b78b5d1f76408794f38bf0f8e7310b1 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the property at the given index. If propertyIndex is greater or equal to the properties count, the behaviour is undefined.  <a href="classrfk_1_1_entity.html#a0b78b5d1f76408794f38bf0f8e7310b1">More...</a><br /></td></tr>
<tr class="separator:a0b78b5d1f76408794f38bf0f8e7310b1 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="memTemplParams" colspan="2">template&lt;typename PropertyType , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;Property, PropertyType&gt; &amp;&amp; !std::is_same_v&lt;PropertyType, Property&gt;&gt;&gt; </td></tr>
<tr class="memitem:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD PropertyType const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a05d7085bf7604499b2240d527fced26e">getProperty</a> (bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a property of a given type from this entity.  <a href="classrfk_1_1_entity.html#a05d7085bf7604499b2240d527fced26e">More...</a><br /></td></tr>
<tr class="separator:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181a40d213920fc16895795829cdb2cf inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a181a40d213920fc16895795829cdb2cf">getProperty</a> (<a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;archetype, bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:a181a40d213920fc16895795829cdb2cf inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first property matching with the provided archetype.  <a href="classrfk_1_1_entity.html#a181a40d213920fc16895795829cdb2cf">More...</a><br /></td></tr>
<tr class="separator:a181a40d213920fc16895795829cdb2cf inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f771df5126a64199aa8de1a4c31f08b inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a2f771df5126a64199aa8de1a4c31f08b">getPropertyByName</a> (char const *name) const noexcept</td></tr>
<tr class="memdesc:a2f771df5126a64199aa8de1a4c31f08b inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first property named with the provided name.  <a href="classrfk_1_1_entity.html#a2f771df5126a64199aa8de1a4c31f08b">More...</a><br /></td></tr>
<tr class="separator:a2f771df5126a64199aa8de1a4c31f08b inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55b766a0ff8bcbbd3fa5da08bf48414 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#ac55b766a0ff8bcbbd3fa5da08bf48414">getPropertyByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:ac55b766a0ff8bcbbd3fa5da08bf48414 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a property matching with a predicate.  <a href="classrfk_1_1_entity.html#ac55b766a0ff8bcbbd3fa5da08bf48414">More...</a><br /></td></tr>
<tr class="separator:ac55b766a0ff8bcbbd3fa5da08bf48414 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="memTemplParams" colspan="2">template&lt;typename PropertyType , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;Property, PropertyType&gt; &amp;&amp; !std::is_same_v&lt;PropertyType, Property&gt;&gt;&gt; </td></tr>
<tr class="memitem:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; PropertyType const * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a7dd90b03c80098a53899794995e436b4">getProperties</a> (bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties matching with the provided archetype. If PropertyType uses multiple inheritance, its first inherited type must be <a class="el" href="classrfk_1_1_property.html" title="Base class to inherit from to define new properties.">rfk::Property</a> or derived.  <a href="classrfk_1_1_entity.html#a7dd90b03c80098a53899794995e436b4">More...</a><br /></td></tr>
<tr class="separator:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c329db7cd25c27f7f8840bfef57344 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#aa6c329db7cd25c27f7f8840bfef57344">getProperties</a> (<a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;archetype, bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:aa6c329db7cd25c27f7f8840bfef57344 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties matching with the provided archetype.  <a href="classrfk_1_1_entity.html#aa6c329db7cd25c27f7f8840bfef57344">More...</a><br /></td></tr>
<tr class="separator:aa6c329db7cd25c27f7f8840bfef57344 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b90791d4b32b69537b21744908961cf inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a3b90791d4b32b69537b21744908961cf">getPropertiesByName</a> (char const *name) const noexcept</td></tr>
<tr class="memdesc:a3b90791d4b32b69537b21744908961cf inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties named with the provided name.  <a href="classrfk_1_1_entity.html#a3b90791d4b32b69537b21744908961cf">More...</a><br /></td></tr>
<tr class="separator:a3b90791d4b32b69537b21744908961cf inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aa815ce0d56d8d48f780bec404dbac inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a89aa815ce0d56d8d48f780bec404dbac">getPropertiesByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:a89aa815ce0d56d8d48f780bec404dbac inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties matching with a predicate in this entity.  <a href="classrfk_1_1_entity.html#a89aa815ce0d56d8d48f780bec404dbac">More...</a><br /></td></tr>
<tr class="separator:a89aa815ce0d56d8d48f780bec404dbac inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3bc60196aba4e5c1ae66817a0f9f8c inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#afb3bc60196aba4e5c1ae66817a0f9f8c">getPropertiesCount</a> () const noexcept</td></tr>
<tr class="memdesc:afb3bc60196aba4e5c1ae66817a0f9f8c inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of properties attached to this entity.  <a href="classrfk_1_1_entity.html#afb3bc60196aba4e5c1ae66817a0f9f8c">More...</a><br /></td></tr>
<tr class="separator:afb3bc60196aba4e5c1ae66817a0f9f8c inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6b2baecc7c1c3a063ba12950c948ae inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a3b6b2baecc7c1c3a063ba12950c948ae">foreachProperty</a> (<a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> &gt; visitor, void *userData) const</td></tr>
<tr class="memdesc:a3b6b2baecc7c1c3a063ba12950c948ae inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the given visitor on all properties attached to this entity.  <a href="classrfk_1_1_entity.html#a3b6b2baecc7c1c3a063ba12950c948ae">More...</a><br /></td></tr>
<tr class="separator:a3b6b2baecc7c1c3a063ba12950c948ae inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349024a085b2807ade1f7dc12e47a15b inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a349024a085b2807ade1f7dc12e47a15b">getName</a> () const noexcept</td></tr>
<tr class="memdesc:a349024a085b2807ade1f7dc12e47a15b inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the entity.  <a href="classrfk_1_1_entity.html#a349024a085b2807ade1f7dc12e47a15b">More...</a><br /></td></tr>
<tr class="separator:a349024a085b2807ade1f7dc12e47a15b inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fca0dc8eed33bf14abb616fc99b9fcd inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a9fca0dc8eed33bf14abb616fc99b9fcd">hasSameName</a> (char const *name) const noexcept</td></tr>
<tr class="memdesc:a9fca0dc8eed33bf14abb616fc99b9fcd inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that this entity has the same name as the provided string.  <a href="classrfk_1_1_entity.html#a9fca0dc8eed33bf14abb616fc99b9fcd">More...</a><br /></td></tr>
<tr class="separator:a9fca0dc8eed33bf14abb616fc99b9fcd inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88488c7a3f458b81dda29f5ba664e6c inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#ac88488c7a3f458b81dda29f5ba664e6c">getId</a> () const noexcept</td></tr>
<tr class="memdesc:ac88488c7a3f458b81dda29f5ba664e6c inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the program-unique id of the entity.  <a href="classrfk_1_1_entity.html#ac88488c7a3f458b81dda29f5ba664e6c">More...</a><br /></td></tr>
<tr class="separator:ac88488c7a3f458b81dda29f5ba664e6c inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4a1f4ec5fa498f834a1c1da7553afe inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="namespacerfk.html#af958ab385009c79cc3a27e9b3183c5d5">EEntityKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#afd4a1f4ec5fa498f834a1c1da7553afe">getKind</a> () const noexcept</td></tr>
<tr class="memdesc:afd4a1f4ec5fa498f834a1c1da7553afe inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the kind of the entity. Knowing the kind allows to safely cast to child classes. Check the EEntityKind documentation for more information.  <a href="classrfk_1_1_entity.html#afd4a1f4ec5fa498f834a1c1da7553afe">More...</a><br /></td></tr>
<tr class="separator:afd4a1f4ec5fa498f834a1c1da7553afe inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f4b0c6a592184803c413258961511 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_entity.html">Entity</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a640f4b0c6a592184803c413258961511">getOuterEntity</a> () const noexcept</td></tr>
<tr class="memdesc:a640f4b0c6a592184803c413258961511 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the outer entity of the entity. It basically corresponds to the entity this entity was declared in from a source-code point of view. A nullptr outer entity means the entity was declared at file level.  <a href="classrfk_1_1_entity.html#a640f4b0c6a592184803c413258961511">More...</a><br /></td></tr>
<tr class="separator:a640f4b0c6a592184803c413258961511 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4089b9c11fea52e987d5975f1d8455 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#abf4089b9c11fea52e987d5975f1d8455">addProperty</a> (<a class="el" href="classrfk_1_1_property.html">Property</a> const &amp;property) noexcept</td></tr>
<tr class="memdesc:abf4089b9c11fea52e987d5975f1d8455 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a property to this entity.  <a href="classrfk_1_1_entity.html#abf4089b9c11fea52e987d5975f1d8455">More...</a><br /></td></tr>
<tr class="separator:abf4089b9c11fea52e987d5975f1d8455 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1768c2e434411991a5badc9d38956d96 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a1768c2e434411991a5badc9d38956d96">setOuterEntity</a> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const *outerEntity) noexcept</td></tr>
<tr class="memdesc:a1768c2e434411991a5badc9d38956d96 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for the field _outerEntity.  <a href="classrfk_1_1_entity.html#a1768c2e434411991a5badc9d38956d96">More...</a><br /></td></tr>
<tr class="separator:a1768c2e434411991a5badc9d38956d96 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48595d14a255dd9d76f1f6c14acb0a0 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#ac48595d14a255dd9d76f1f6c14acb0a0">setPropertiesCapacity</a> (std::size_t capacity) noexcept</td></tr>
<tr class="memdesc:ac48595d14a255dd9d76f1f6c14acb0a0 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of properties for this entity. Useful to avoid reallocations when adding a lot of properties. If the number of properties is already &gt;= to the provided capacity, this method has no effect.  <a href="classrfk_1_1_entity.html#ac48595d14a255dd9d76f1f6c14acb0a0">More...</a><br /></td></tr>
<tr class="separator:ac48595d14a255dd9d76f1f6c14acb0a0 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b62164e710f9a5600d827932f8ef98b inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a6b62164e710f9a5600d827932f8ef98b" name="a6b62164e710f9a5600d827932f8ef98b"></a>
<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;)=delete</td></tr>
<tr class="separator:a6b62164e710f9a5600d827932f8ef98b inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a0f7549543c0d8102c99b8befef70d inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="ab5a0f7549543c0d8102c99b8befef70d" name="ab5a0f7549543c0d8102c99b8befef70d"></a>
<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab5a0f7549543c0d8102c99b8befef70d inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58eb57c553e9773b2b05a5f163561e72 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a58eb57c553e9773b2b05a5f163561e72" name="a58eb57c553e9773b2b05a5f163561e72"></a>
RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;other) const noexcept</td></tr>
<tr class="separator:a58eb57c553e9773b2b05a5f163561e72 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96260f434f193f8f2675ba3de3bc8e05 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a96260f434f193f8f2675ba3de3bc8e05" name="a96260f434f193f8f2675ba3de3bc8e05"></a>
RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;other) const noexcept</td></tr>
<tr class="separator:a96260f434f193f8f2675ba3de3bc8e05 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classrfk_1_1_method_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrfk_1_1_method_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrfk_1_1_method_base.html">rfk::MethodBase</a></td></tr>
<tr class="memitem:ac0a2bc4e0c51619e19f3c4c30baf50a3 inherit pro_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top"><a id="ac0a2bc4e0c51619e19f3c4c30baf50a3" name="ac0a2bc4e0c51619e19f3c4c30baf50a3"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>MethodBase</b> (MethodBaseImpl *implementation) noexcept</td></tr>
<tr class="separator:ac0a2bc4e0c51619e19f3c4c30baf50a3 inherit pro_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07edc0bfc874d496db4c9c87a7748a61 inherit pro_methods_classrfk_1_1_method_base"><td class="memItemLeft" align="right" valign="top"><a id="a07edc0bfc874d496db4c9c87a7748a61" name="a07edc0bfc874d496db4c9c87a7748a61"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>MethodBase</b> (<a class="el" href="classrfk_1_1_method_base.html">MethodBase</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:a07edc0bfc874d496db4c9c87a7748a61 inherit pro_methods_classrfk_1_1_method_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrfk_1_1_function_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrfk_1_1_function_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrfk_1_1_function_base.html">rfk::FunctionBase</a></td></tr>
<tr class="memitem:a8a890c552b4fefc46d62f1162f6ea48b inherit pro_methods_classrfk_1_1_function_base"><td class="memItemLeft" align="right" valign="top"><a id="a8a890c552b4fefc46d62f1162f6ea48b" name="a8a890c552b4fefc46d62f1162f6ea48b"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>FunctionBase</b> (FunctionBaseImpl *implementation) noexcept</td></tr>
<tr class="separator:a8a890c552b4fefc46d62f1162f6ea48b inherit pro_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b6d84ac0445694ab6db452c5808ae7 inherit pro_methods_classrfk_1_1_function_base"><td class="memItemLeft" align="right" valign="top"><a id="aa1b6d84ac0445694ab6db452c5808ae7" name="aa1b6d84ac0445694ab6db452c5808ae7"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>FunctionBase</b> (<a class="el" href="classrfk_1_1_function_base.html">FunctionBase</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:aa1b6d84ac0445694ab6db452c5808ae7 inherit pro_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e77c0caab001d7c46f1a1c196a77a37 inherit pro_methods_classrfk_1_1_function_base"><td class="memItemLeft" align="right" valign="top"><a id="a0e77c0caab001d7c46f1a1c196a77a37" name="a0e77c0caab001d7c46f1a1c196a77a37"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>RFK_GEN_GET_PIMPL</b> (FunctionBaseImpl, Entity::getPimpl())</td></tr>
<tr class="separator:a0e77c0caab001d7c46f1a1c196a77a37 inherit pro_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b6906d5b93d35357595e066ae49e8f inherit pro_methods_classrfk_1_1_function_base"><td class="memTemplParams" colspan="2">template&lt;typename... ArgTypes&gt; </td></tr>
<tr class="memitem:a39b6906d5b93d35357595e066ae49e8f inherit pro_methods_classrfk_1_1_function_base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#a39b6906d5b93d35357595e066ae49e8f">checkParametersCount</a> () const</td></tr>
<tr class="memdesc:a39b6906d5b93d35357595e066ae49e8f inherit pro_methods_classrfk_1_1_function_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the provided argument count is the same as this function's.  <a href="classrfk_1_1_function_base.html#a39b6906d5b93d35357595e066ae49e8f">More...</a><br /></td></tr>
<tr class="separator:a39b6906d5b93d35357595e066ae49e8f inherit pro_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1620f9199bc2c74b39e94a377e0714a inherit pro_methods_classrfk_1_1_function_base"><td class="memTemplParams" colspan="2">template&lt;typename... ArgTypes&gt; </td></tr>
<tr class="memitem:ae1620f9199bc2c74b39e94a377e0714a inherit pro_methods_classrfk_1_1_function_base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#ae1620f9199bc2c74b39e94a377e0714a">checkParameterTypes</a> () const</td></tr>
<tr class="memdesc:ae1620f9199bc2c74b39e94a377e0714a inherit pro_methods_classrfk_1_1_function_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the provided types are the same as this function parameter types.  <a href="classrfk_1_1_function_base.html#ae1620f9199bc2c74b39e94a377e0714a">More...</a><br /></td></tr>
<tr class="separator:ae1620f9199bc2c74b39e94a377e0714a inherit pro_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ff212a9f870883a403e1b0aa24f121 inherit pro_methods_classrfk_1_1_function_base"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:a76ff212a9f870883a403e1b0aa24f121 inherit pro_methods_classrfk_1_1_function_base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_function_base.html#a76ff212a9f870883a403e1b0aa24f121">checkReturnType</a> () const</td></tr>
<tr class="memdesc:a76ff212a9f870883a403e1b0aa24f121 inherit pro_methods_classrfk_1_1_function_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the provided type is the same as this function return type.  <a href="classrfk_1_1_function_base.html#a76ff212a9f870883a403e1b0aa24f121">More...</a><br /></td></tr>
<tr class="separator:a76ff212a9f870883a403e1b0aa24f121 inherit pro_methods_classrfk_1_1_function_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrfk_1_1_entity"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrfk_1_1_entity')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrfk_1_1_entity.html">rfk::Entity</a></td></tr>
<tr class="memitem:a502d0895419cf5420ddfffb2c9743fe2 inherit pro_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a502d0895419cf5420ddfffb2c9743fe2" name="a502d0895419cf5420ddfffb2c9743fe2"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Entity</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:a502d0895419cf5420ddfffb2c9743fe2 inherit pro_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b757749f74869d1f5f7b8257cd40591 inherit pro_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a4b757749f74869d1f5f7b8257cd40591" name="a4b757749f74869d1f5f7b8257cd40591"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Entity</b> (EntityImpl *implementation) noexcept</td></tr>
<tr class="separator:a4b757749f74869d1f5f7b8257cd40591 inherit pro_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a777fa1a63dabef8f7a7276c254246a46" name="a777fa1a63dabef8f7a7276c254246a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777fa1a63dabef8f7a7276c254246a46">&#9670;&nbsp;</a></span>checkedInvoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType  = void, typename CallerType , typename... ArgTypes, typename  = std::enable_if_t&lt;!std::is_const_v&lt;CallerType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnType rfk::Method::checkedInvoke </td>
          <td>(</td>
          <td class="paramtype">CallerType &amp;&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the function with the forwarded argument(s) if any, and return the result. The return type and arguments types will be strictly checked before calling the function. If there is any mismatch, <a class="el" href="classrfk_1_1_arg_count_mismatch.html">ArgCountMismatch</a>, <a class="el" href="classrfk_1_1_arg_type_mismatch.html">ArgTypeMismatch</a> or <a class="el" href="classrfk_1_1_return_type_mismatch.html">ReturnTypeMismatch</a> will be thrown. <b>WARNING 1</b>: Unreflected archetypes can't be compared, so they will pass through the type checks. <b>WARNING 2</b>: Template type deduction might forward wrong types to the function (int instead of int8_t or char* instead of std::string for example), so it is recommended to explicitly specify all template types when calling the function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReturnType</td><td>Return type of the function. </td></tr>
    <tr><td class="paramname">CallerType</td><td><a class="el" href="classrfk_1_1_type.html">Type</a> of the calling struct/class. </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>.. ArgTypes <a class="el" href="classrfk_1_1_type.html">Type</a> of all arguments. This can in some cases be omitted thanks to template deduction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td><a class="el" href="classrfk_1_1_object.html">Object</a> instance calling the method. It MUST implement the getArchetype method (<a class="el" href="classrfk_1_1_object.html">rfk::Object</a>) for all safety checks to be performed properly. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments forwarded to the function call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the function call.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_arg_count_mismatch.html">ArgCountMismatch</a></td><td>if sizeof...(ArgTypes) is not the same as the value returned by <a class="el" href="classrfk_1_1_function_base.html#ae407b16a382f88da360e50b71d3114d9" title="Get the number of parameters of this function.">getParametersCount()</a>. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_arg_type_mismatch.html">ArgTypeMismatch</a></td><td>if ArgTypes... are not strictly the same as this function parameter types. <b>WARNING</b>: Be careful to template deduction. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_return_type_mismatch.html">ReturnTypeMismatch</a></td><td>if ReturnType is not strictly the same as this function return type. </td></tr>
    <tr><td class="paramname">NotReflectedClass</td><td>if the caller struct is not reflected (<a class="el" href="namespacerfk.html#ad271284a71f8ca43f34686e4f9740393" title="Get the archetype of any type if it exists. Note that this method will always return nullptr on prote...">rfk::getArchetype&lt;CallerType&gt;()</a> == nullptr). </td></tr>
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_invalid_caller.html">InvalidCaller</a></td><td>if the caller struct can't call the method (struct that introduced this method is not in the caller parent's hierarchy). </td></tr>
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the underlying function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fccea5413d86d922fb65fd42f3ca5c4" name="a1fccea5413d86d922fb65fd42f3ca5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fccea5413d86d922fb65fd42f3ca5c4">&#9670;&nbsp;</a></span>invoke()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType  = void, typename CallerType , typename... ArgTypes, typename  = std::enable_if_t&lt;!std::is_const_v&lt;CallerType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnType rfk::Method::invoke </td>
          <td>(</td>
          <td class="paramtype">CallerType &amp;&#160;</td>
          <td class="paramname"><em>caller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArgTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the function with the forwarded argument(s) if any, and return the result. Providing bad return type / parameters is undefined behaviour. <b>WARNING</b>: Template type deduction might forward wrong types to the function (int instead of int8_t or char* instead of std::string for example), so it is recommended to explicitly specify all template types when calling the function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReturnType</td><td>Return type of the function. </td></tr>
    <tr><td class="paramname">CallerType</td><td><a class="el" href="classrfk_1_1_type.html">Type</a> of the calling struct/class. </td></tr>
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<p>.. ArgTypes <a class="el" href="classrfk_1_1_type.html">Type</a> of all arguments. This can in some cases be omitted thanks to template deduction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">caller</td><td><a class="el" href="classrfk_1_1_object.html">Object</a> instance calling the method. Caller is not required to implement the getArchetype method, but the invoke method will likely crash if the memory offset between the CallerType static archetype and its actual dynamic archetype is different from 0. If CallerType implements the getArchetype method (<a class="el" href="classrfk_1_1_object.html">rfk::Object</a>), no such error will ever happen. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments forwarded to the function call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the function call.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exception potentially thrown from the underlying function. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_const_violation.html">ConstViolation</a></td><td>if the caller is const but the method is non-const. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Refureku/Library/Include/Public/Refureku/TypeInfo/Functions/<a class="el" href="_method_8h_source.html">Method.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerfk.html">rfk</a></li><li class="navelem"><a class="el" href="classrfk_1_1_method.html">Method</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
