<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Refureku: rfk::Vector&lt; T, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="rfk-compact-logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Refureku<span id="projectnumber">&#160;v2.0.3</span>
   </div>
   <div id="projectbrief">C++17 runtime reflection library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrfk_1_1_vector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrfk_1_1_vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rfk::Vector&lt; T, Allocator &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2cd2e5945d9d2454dee16d8fcab3ca16"><td class="memItemLeft" align="right" valign="top"><a id="a2cd2e5945d9d2454dee16d8fcab3ca16" name="a2cd2e5945d9d2454dee16d8fcab3ca16"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> (std::size_t initialCapacity=0u) noexcept</td></tr>
<tr class="separator:a2cd2e5945d9d2454dee16d8fcab3ca16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94819d30b4097fd822a995e7b5965ab9"><td class="memTemplParams" colspan="2">template&lt;typename U , typename UAlloc &gt; </td></tr>
<tr class="memitem:a94819d30b4097fd822a995e7b5965ab9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#a94819d30b4097fd822a995e7b5965ab9">Vector</a> (<a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; U, UAlloc &gt; &amp;&amp;) noexcept</td></tr>
<tr class="separator:a94819d30b4097fd822a995e7b5965ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4551e1e1f82b9e53bf370cfb0f3cc48e"><td class="memItemLeft" align="right" valign="top"><a id="a4551e1e1f82b9e53bf370cfb0f3cc48e" name="a4551e1e1f82b9e53bf370cfb0f3cc48e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> (<a class="el" href="classrfk_1_1_vector.html">Vector</a> const &amp;)</td></tr>
<tr class="separator:a4551e1e1f82b9e53bf370cfb0f3cc48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cef1df83acb39c4bc1c01dbcc9d33a1"><td class="memItemLeft" align="right" valign="top"><a id="a8cef1df83acb39c4bc1c01dbcc9d33a1" name="a8cef1df83acb39c4bc1c01dbcc9d33a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b> (<a class="el" href="classrfk_1_1_vector.html">Vector</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:a8cef1df83acb39c4bc1c01dbcc9d33a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536fa4274f42515d050771fbf5c8a8e1"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#a536fa4274f42515d050771fbf5c8a8e1">front</a> () noexcept</td></tr>
<tr class="memdesc:a536fa4274f42515d050771fbf5c8a8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the first element of the vector. The behaviour is undefined if the vector is empty.  <a href="classrfk_1_1_vector.html#a536fa4274f42515d050771fbf5c8a8e1">More...</a><br /></td></tr>
<tr class="separator:a536fa4274f42515d050771fbf5c8a8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fb34923381ef94d166c5c74e778c16"><td class="memItemLeft" align="right" valign="top"><a id="ae2fb34923381ef94d166c5c74e778c16" name="ae2fb34923381ef94d166c5c74e778c16"></a>
T const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>front</b> () const noexcept</td></tr>
<tr class="separator:ae2fb34923381ef94d166c5c74e778c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ad9a7cd6fa2c4ae89266aaa7c1c118"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#a71ad9a7cd6fa2c4ae89266aaa7c1c118">back</a> () noexcept</td></tr>
<tr class="memdesc:a71ad9a7cd6fa2c4ae89266aaa7c1c118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the last element of the vector. The behaviour is undefined if the vector is empty.  <a href="classrfk_1_1_vector.html#a71ad9a7cd6fa2c4ae89266aaa7c1c118">More...</a><br /></td></tr>
<tr class="separator:a71ad9a7cd6fa2c4ae89266aaa7c1c118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0249bafe713aba2e6d0dc7509111a3a"><td class="memItemLeft" align="right" valign="top"><a id="ab0249bafe713aba2e6d0dc7509111a3a" name="ab0249bafe713aba2e6d0dc7509111a3a"></a>
T const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>back</b> () const noexcept</td></tr>
<tr class="separator:ab0249bafe713aba2e6d0dc7509111a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28195367261dddabe6ac5de0ee5bbd9"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#ae28195367261dddabe6ac5de0ee5bbd9">data</a> () noexcept</td></tr>
<tr class="memdesc:ae28195367261dddabe6ac5de0ee5bbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the underlying allocated memory.  <a href="classrfk_1_1_vector.html#ae28195367261dddabe6ac5de0ee5bbd9">More...</a><br /></td></tr>
<tr class="separator:ae28195367261dddabe6ac5de0ee5bbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893638f1ac9f225c51600882a0d507d9"><td class="memItemLeft" align="right" valign="top"><a id="a893638f1ac9f225c51600882a0d507d9" name="a893638f1ac9f225c51600882a0d507d9"></a>
T const *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const noexcept</td></tr>
<tr class="separator:a893638f1ac9f225c51600882a0d507d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012a65ac2cbbea54b133e8eaf85bd160"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#a012a65ac2cbbea54b133e8eaf85bd160">reserve</a> (std::size_t <a class="el" href="classrfk_1_1_vector.html#aadda891bcceb50c2a7979a0c197ca8e8">capacity</a>)</td></tr>
<tr class="memdesc:a012a65ac2cbbea54b133e8eaf85bd160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocate the underlying memory to have enough space to fit capacity elements. No reallocation happens if the provided capacity is equal or smaller than the current capacity.  <a href="classrfk_1_1_vector.html#a012a65ac2cbbea54b133e8eaf85bd160">More...</a><br /></td></tr>
<tr class="separator:a012a65ac2cbbea54b133e8eaf85bd160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4023f871ae1eacfbb4da242bf762c739"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#a4023f871ae1eacfbb4da242bf762c739">resize</a> (std::size_t <a class="el" href="classrfk_1_1_vector.html#a1efec2c5878512b4037a7ca128acfb82">size</a>)</td></tr>
<tr class="memdesc:a4023f871ae1eacfbb4da242bf762c739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the vector so that it has exactly the specified size. Reallocation occurs if the size is greater than the current capacity. Objects are default constructed if the specified size is greater than the current size.  <a href="classrfk_1_1_vector.html#a4023f871ae1eacfbb4da242bf762c739">More...</a><br /></td></tr>
<tr class="separator:a4023f871ae1eacfbb4da242bf762c739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efec2c5878512b4037a7ca128acfb82"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#a1efec2c5878512b4037a7ca128acfb82">size</a> () const noexcept</td></tr>
<tr class="memdesc:a1efec2c5878512b4037a7ca128acfb82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of elements stored in the vector.  <a href="classrfk_1_1_vector.html#a1efec2c5878512b4037a7ca128acfb82">More...</a><br /></td></tr>
<tr class="separator:a1efec2c5878512b4037a7ca128acfb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadda891bcceb50c2a7979a0c197ca8e8"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#aadda891bcceb50c2a7979a0c197ca8e8">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:aadda891bcceb50c2a7979a0c197ca8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of elements storable in the vector without reallocation.  <a href="classrfk_1_1_vector.html#aadda891bcceb50c2a7979a0c197ca8e8">More...</a><br /></td></tr>
<tr class="separator:aadda891bcceb50c2a7979a0c197ca8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa063726c4f24b0a100c82a8573e81baf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#aa063726c4f24b0a100c82a8573e81baf">empty</a> () const noexcept</td></tr>
<tr class="memdesc:aa063726c4f24b0a100c82a8573e81baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the container contains no elements.  <a href="classrfk_1_1_vector.html#aa063726c4f24b0a100c82a8573e81baf">More...</a><br /></td></tr>
<tr class="separator:aa063726c4f24b0a100c82a8573e81baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720e35f3c9c7d7a13f6bb8eb7c2de80e"><td class="memItemLeft" align="right" valign="top"><a id="a720e35f3c9c7d7a13f6bb8eb7c2de80e" name="a720e35f3c9c7d7a13f6bb8eb7c2de80e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:a720e35f3c9c7d7a13f6bb8eb7c2de80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements from the vector. <br /></td></tr>
<tr class="separator:a720e35f3c9c7d7a13f6bb8eb7c2de80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99efd9663e626c0da1bcf417d7b34dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#ac99efd9663e626c0da1bcf417d7b34dc">push_back</a> (T const &amp;value)</td></tr>
<tr class="memdesc:ac99efd9663e626c0da1bcf417d7b34dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the vector.  <a href="classrfk_1_1_vector.html#ac99efd9663e626c0da1bcf417d7b34dc">More...</a><br /></td></tr>
<tr class="separator:ac99efd9663e626c0da1bcf417d7b34dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b87a6d04d6462a1c98f114850b0cc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#ad8b87a6d04d6462a1c98f114850b0cc4">push_back</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:ad8b87a6d04d6462a1c98f114850b0cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an element to the vector.  <a href="classrfk_1_1_vector.html#ad8b87a6d04d6462a1c98f114850b0cc4">More...</a><br /></td></tr>
<tr class="separator:ad8b87a6d04d6462a1c98f114850b0cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0609ff77fc4d3c4e4620c75ecd5ccd36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#a0609ff77fc4d3c4e4620c75ecd5ccd36">push_back</a> (<a class="el" href="classrfk_1_1_vector.html">Vector</a> const &amp;other)</td></tr>
<tr class="memdesc:a0609ff77fc4d3c4e4620c75ecd5ccd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all elements from a vector at the end of this vector.  <a href="classrfk_1_1_vector.html#a0609ff77fc4d3c4e4620c75ecd5ccd36">More...</a><br /></td></tr>
<tr class="separator:a0609ff77fc4d3c4e4620c75ecd5ccd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c2988270d04205258a5a7536ee89b2"><td class="memItemLeft" align="right" valign="top"><a id="a25c2988270d04205258a5a7536ee89b2" name="a25c2988270d04205258a5a7536ee89b2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (<a class="el" href="classrfk_1_1_vector.html">Vector</a> &amp;&amp;other)</td></tr>
<tr class="separator:a25c2988270d04205258a5a7536ee89b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9264ba6f56db8f66682bc207f1073ea"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae9264ba6f56db8f66682bc207f1073ea"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#ae9264ba6f56db8f66682bc207f1073ea">emplace_back</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae9264ba6f56db8f66682bc207f1073ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct in place an element at the end of the vector with the provided arguments.  <a href="classrfk_1_1_vector.html#ae9264ba6f56db8f66682bc207f1073ea">More...</a><br /></td></tr>
<tr class="separator:ae9264ba6f56db8f66682bc207f1073ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef2e37430aabd7bdba1597c5cda5d2d"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#aaef2e37430aabd7bdba1597c5cda5d2d">begin</a> () noexcept</td></tr>
<tr class="memdesc:aaef2e37430aabd7bdba1597c5cda5d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the first element. If the vector is empty, the pointed memory is undefined.  <a href="classrfk_1_1_vector.html#aaef2e37430aabd7bdba1597c5cda5d2d">More...</a><br /></td></tr>
<tr class="separator:aaef2e37430aabd7bdba1597c5cda5d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5789938b96afca51a705f5bd59f01901"><td class="memItemLeft" align="right" valign="top"><a id="a5789938b96afca51a705f5bd59f01901" name="a5789938b96afca51a705f5bd59f01901"></a>
T const *&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:a5789938b96afca51a705f5bd59f01901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2642818038dc306eefa8c28146aabcd"><td class="memItemLeft" align="right" valign="top"><a id="af2642818038dc306eefa8c28146aabcd" name="af2642818038dc306eefa8c28146aabcd"></a>
T const *&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:af2642818038dc306eefa8c28146aabcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0045fa518853a58f34a915e17ca4e6e6"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#a0045fa518853a58f34a915e17ca4e6e6">end</a> () noexcept</td></tr>
<tr class="memdesc:a0045fa518853a58f34a915e17ca4e6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer past the last element.  <a href="classrfk_1_1_vector.html#a0045fa518853a58f34a915e17ca4e6e6">More...</a><br /></td></tr>
<tr class="separator:a0045fa518853a58f34a915e17ca4e6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe3668fc7adec25070024a976749da1"><td class="memItemLeft" align="right" valign="top"><a id="acbe3668fc7adec25070024a976749da1" name="acbe3668fc7adec25070024a976749da1"></a>
T const *&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:acbe3668fc7adec25070024a976749da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a60f7da18c21599db1a4f6658b60eb"><td class="memItemLeft" align="right" valign="top"><a id="a20a60f7da18c21599db1a4f6658b60eb" name="a20a60f7da18c21599db1a4f6658b60eb"></a>
T const *&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:a20a60f7da18c21599db1a4f6658b60eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b44df72a4db5d98fa0754cb3acd7e4"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_vector.html#a15b44df72a4db5d98fa0754cb3acd7e4">operator[]</a> (std::size_t index) noexcept</td></tr>
<tr class="memdesc:a15b44df72a4db5d98fa0754cb3acd7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the index(th) element in the vector.  <a href="classrfk_1_1_vector.html#a15b44df72a4db5d98fa0754cb3acd7e4">More...</a><br /></td></tr>
<tr class="separator:a15b44df72a4db5d98fa0754cb3acd7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e3a68be5fe00ec187621c78bb0f80d"><td class="memItemLeft" align="right" valign="top"><a id="af3e3a68be5fe00ec187621c78bb0f80d" name="af3e3a68be5fe00ec187621c78bb0f80d"></a>
T const &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (std::size_t index) const noexcept</td></tr>
<tr class="separator:af3e3a68be5fe00ec187621c78bb0f80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24203f6707b5e399536cf2f0db546b32"><td class="memItemLeft" align="right" valign="top"><a id="a24203f6707b5e399536cf2f0db546b32" name="a24203f6707b5e399536cf2f0db546b32"></a>
<a class="el" href="classrfk_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrfk_1_1_vector.html">Vector</a> const &amp;)</td></tr>
<tr class="separator:a24203f6707b5e399536cf2f0db546b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b13901ca1a9f36d306d3efe2462eb5f"><td class="memItemLeft" align="right" valign="top"><a id="a5b13901ca1a9f36d306d3efe2462eb5f" name="a5b13901ca1a9f36d306d3efe2462eb5f"></a>
<a class="el" href="classrfk_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrfk_1_1_vector.html">Vector</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:a5b13901ca1a9f36d306d3efe2462eb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a94819d30b4097fd822a995e7b5965ab9" name="a94819d30b4097fd822a995e7b5965ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94819d30b4097fd822a995e7b5965ab9">&#9670;&nbsp;</a></span>Vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename UAlloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::Vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; U, UAlloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Retrieve data from another type U. NOT SAFE UNLESS YOU EXACTLY KNOW WHAT YOU DO. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a71ad9a7cd6fa2c4ae89266aaa7c1c118" name="a71ad9a7cd6fa2c4ae89266aaa7c1c118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ad9a7cd6fa2c4ae89266aaa7c1c118">&#9670;&nbsp;</a></span>back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the last element of the vector. The behaviour is undefined if the vector is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the last element of the vector. </dd></dl>

</div>
</div>
<a id="aaef2e37430aabd7bdba1597c5cda5d2d" name="aaef2e37430aabd7bdba1597c5cda5d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef2e37430aabd7bdba1597c5cda5d2d">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the first element. If the vector is empty, the pointed memory is undefined. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element. </dd></dl>

</div>
</div>
<a id="aadda891bcceb50c2a7979a0c197ca8e8" name="aadda891bcceb50c2a7979a0c197ca8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadda891bcceb50c2a7979a0c197ca8e8">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum number of elements storable in the vector without reallocation. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of elements storable in the vector without reallocation. </dd></dl>

</div>
</div>
<a id="ae28195367261dddabe6ac5de0ee5bbd9" name="ae28195367261dddabe6ac5de0ee5bbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28195367261dddabe6ac5de0ee5bbd9">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the underlying allocated memory. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the underlying allocated memory. </dd></dl>

</div>
</div>
<a id="ae9264ba6f56db8f66682bc207f1073ea" name="ae9264ba6f56db8f66682bc207f1073ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9264ba6f56db8f66682bc207f1073ea">&#9670;&nbsp;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct in place an element at the end of the vector with the provided arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>args Args forwarded to the object constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the constructed element. </dd></dl>

</div>
</div>
<a id="aa063726c4f24b0a100c82a8573e81baf" name="aa063726c4f24b0a100c82a8573e81baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa063726c4f24b0a100c82a8573e81baf">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the container contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>true if there are no elements in the vector, else false. </dd></dl>

</div>
</div>
<a id="a0045fa518853a58f34a915e17ca4e6e6" name="a0045fa518853a58f34a915e17ca4e6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0045fa518853a58f34a915e17ca4e6e6">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer past the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer past the last element. </dd></dl>

</div>
</div>
<a id="a536fa4274f42515d050771fbf5c8a8e1" name="a536fa4274f42515d050771fbf5c8a8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536fa4274f42515d050771fbf5c8a8e1">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the first element of the vector. The behaviour is undefined if the vector is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the first element of the vector. </dd></dl>

</div>
</div>
<a id="a15b44df72a4db5d98fa0754cb3acd7e4" name="a15b44df72a4db5d98fa0754cb3acd7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b44df72a4db5d98fa0754cb3acd7e4">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the index(th) element in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of the element to access.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the index(th) element in the vector. </dd></dl>

</div>
</div>
<a id="ad8b87a6d04d6462a1c98f114850b0cc4" name="ad8b87a6d04d6462a1c98f114850b0cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b87a6d04d6462a1c98f114850b0cc4">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an element to the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to forward. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac99efd9663e626c0da1bcf417d7b34dc" name="ac99efd9663e626c0da1bcf417d7b34dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99efd9663e626c0da1bcf417d7b34dc">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an element to the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The object to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0609ff77fc4d3c4e4620c75ecd5ccd36" name="a0609ff77fc4d3c4e4620c75ecd5ccd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0609ff77fc4d3c4e4620c75ecd5ccd36">&#9670;&nbsp;</a></span>push_back() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add all elements from a vector at the end of this vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The vector which elements must be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a012a65ac2cbbea54b133e8eaf85bd160" name="a012a65ac2cbbea54b133e8eaf85bd160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012a65ac2cbbea54b133e8eaf85bd160">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reallocate the underlying memory to have enough space to fit capacity elements. No reallocation happens if the provided capacity is equal or smaller than the current capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>New capacity. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4023f871ae1eacfbb4da242bf762c739" name="a4023f871ae1eacfbb4da242bf762c739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4023f871ae1eacfbb4da242bf762c739">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the vector so that it has exactly the specified size. Reallocation occurs if the size is greater than the current capacity. Objects are default constructed if the specified size is greater than the current size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1efec2c5878512b4037a7ca128acfb82" name="a1efec2c5878512b4037a7ca128acfb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1efec2c5878512b4037a7ca128acfb82">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename <a class="el" href="classrfk_1_1_allocator.html">Allocator</a>  = rfk::Allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classrfk_1_1_vector.html">rfk::Vector</a>&lt; T, <a class="el" href="classrfk_1_1_allocator.html">Allocator</a> &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of elements stored in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements stored in the vector. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Refureku/Library/Include/Public/Refureku/Containers/<a class="el" href="_vector_8h_source.html">Vector.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerfk.html">rfk</a></li><li class="navelem"><a class="el" href="classrfk_1_1_vector.html">Vector</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
