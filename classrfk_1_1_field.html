<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Refureku: rfk::Field Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="rfk-compact-logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Refureku<span id="projectnumber">&#160;v2.2.0</span>
   </div>
   <div id="projectbrief">C++17 runtime reflection library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classrfk_1_1_field.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classrfk_1_1_field-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rfk::Field Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for rfk::Field:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classrfk_1_1_field.png" usemap="#rfk::Field_map" alt=""/>
  <map id="rfk::Field_map" name="rfk::Field_map">
<area href="classrfk_1_1_field_base.html" alt="rfk::FieldBase" shape="rect" coords="0,112,109,136"/>
<area href="classrfk_1_1_variable_base.html" alt="rfk::VariableBase" shape="rect" coords="0,56,109,80"/>
<area href="classrfk_1_1_entity.html" alt="rfk::Entity" shape="rect" coords="0,0,109,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7a926b603225a4cf371042f2d6add7a1"><td class="memItemLeft" align="right" valign="top"><a id="a7a926b603225a4cf371042f2d6add7a1" name="a7a926b603225a4cf371042f2d6add7a1"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Field</b> (char const *name, std::size_t id, <a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;type, <a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7a">EFieldFlags</a> flags, <a class="el" href="classrfk_1_1_struct.html">Struct</a> const *owner, std::size_t memoryOffset, <a class="el" href="classrfk_1_1_entity.html">Entity</a> const *outerEntity=nullptr) noexcept</td></tr>
<tr class="separator:a7a926b603225a4cf371042f2d6add7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e198f0362b36268cd170ac4b2c200a9"><td class="memItemLeft" align="right" valign="top"><a id="a3e198f0362b36268cd170ac4b2c200a9" name="a3e198f0362b36268cd170ac4b2c200a9"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Field</b> (<a class="el" href="classrfk_1_1_field.html">Field</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:a3e198f0362b36268cd170ac4b2c200a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985da6fc03517fb4a67da2f5dd87cb72"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename InstanceType , typename  = std::enable_if_t&lt;is_value_v&lt;InstanceType&gt; &amp;&amp; internal::IsAdjustableInstanceValue&lt;InstanceType&gt;&gt;&gt; </td></tr>
<tr class="memitem:a985da6fc03517fb4a67da2f5dd87cb72"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#a985da6fc03517fb4a67da2f5dd87cb72">get</a> (InstanceType &amp;instance) const</td></tr>
<tr class="memdesc:a985da6fc03517fb4a67da2f5dd87cb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value corresponding to this field in the provided instance. This method in not safe if you provide a wrong ValueType.  <a href="classrfk_1_1_field.html#a985da6fc03517fb4a67da2f5dd87cb72">More...</a><br /></td></tr>
<tr class="separator:a985da6fc03517fb4a67da2f5dd87cb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554728e8a99550c5d91de7861e08015d"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a554728e8a99550c5d91de7861e08015d"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#a554728e8a99550c5d91de7861e08015d">getUnsafe</a> (void *instance) const</td></tr>
<tr class="memdesc:a554728e8a99550c5d91de7861e08015d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value corresponding to this field in the provided instance. This method in not safe if you provide a wrong ValueType. This method DOES NOT perform any pointer adjustment on the provided instance so it is unsafe if instance is not a valid pointer to an object of the field's owner archetype. Prefer using <a class="el" href="classrfk_1_1_field.html#a985da6fc03517fb4a67da2f5dd87cb72" title="Get the value corresponding to this field in the provided instance. This method in not safe if you pr...">Field::get</a> for safety if you know the static type of your instance in the calling context.  <a href="classrfk_1_1_field.html#a554728e8a99550c5d91de7861e08015d">More...</a><br /></td></tr>
<tr class="separator:a554728e8a99550c5d91de7861e08015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68f57e7fd571a34d378941f68aee237"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:af68f57e7fd571a34d378941f68aee237"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#af68f57e7fd571a34d378941f68aee237">getUnsafe</a> (void const *instance) const</td></tr>
<tr class="memdesc:af68f57e7fd571a34d378941f68aee237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value corresponding to this field in the provided instance. This method in not safe if you provide a wrong ValueType. This method DOES NOT perform any pointer adjustment on the provided instance so it is unsafe if instance is not a valid pointer to an object of the field's owner archetype. Prefer using <a class="el" href="classrfk_1_1_field.html#a985da6fc03517fb4a67da2f5dd87cb72" title="Get the value corresponding to this field in the provided instance. This method in not safe if you pr...">Field::get</a> for safety if you know the static type of your instance in the calling context.  <a href="classrfk_1_1_field.html#af68f57e7fd571a34d378941f68aee237">More...</a><br /></td></tr>
<tr class="separator:af68f57e7fd571a34d378941f68aee237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d398c692a5647118dbba3507153b0e1"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename InstanceType , typename  = std::enable_if_t&lt;is_value_v&lt;InstanceType&gt; &amp;&amp; internal::IsAdjustableInstanceValue&lt;InstanceType&gt;&gt;&gt; </td></tr>
<tr class="memitem:a8d398c692a5647118dbba3507153b0e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#a8d398c692a5647118dbba3507153b0e1">set</a> (InstanceType &amp;instance, ValueType &amp;&amp;value) const</td></tr>
<tr class="memdesc:a8d398c692a5647118dbba3507153b0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value corresponding to this field in the provided instance. This method is not safe if you provide a wrong ValueType.  <a href="classrfk_1_1_field.html#a8d398c692a5647118dbba3507153b0e1">More...</a><br /></td></tr>
<tr class="separator:a8d398c692a5647118dbba3507153b0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e630ab9c3a6c638fcba1919f143f99"><td class="memTemplParams" colspan="2">template&lt;typename InstanceType , typename  = std::enable_if_t&lt;is_value_v&lt;InstanceType&gt; &amp;&amp; internal::IsAdjustableInstanceValue&lt;InstanceType&gt;&gt;&gt; </td></tr>
<tr class="memitem:aa1e630ab9c3a6c638fcba1919f143f99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#aa1e630ab9c3a6c638fcba1919f143f99">set</a> (InstanceType &amp;instance, void const *valuePtr, std::size_t valueSize) const</td></tr>
<tr class="memdesc:aa1e630ab9c3a6c638fcba1919f143f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy valueSize bytes starting from valuePtr into this field's address in instance.  <a href="classrfk_1_1_field.html#aa1e630ab9c3a6c638fcba1919f143f99">More...</a><br /></td></tr>
<tr class="separator:aa1e630ab9c3a6c638fcba1919f143f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bd9ccf0da0e3fd5e830bba8a696294"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ab9bd9ccf0da0e3fd5e830bba8a696294"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#ab9bd9ccf0da0e3fd5e830bba8a696294">setUnsafe</a> (void *instance, ValueType &amp;&amp;value) const</td></tr>
<tr class="memdesc:ab9bd9ccf0da0e3fd5e830bba8a696294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value corresponding to this field in the provided instance. This method is not safe if you provide a wrong ValueType. This method DOES NOT perform any pointer adjustment on the provided instance so it is unsafe if instance is not a valid pointer to an object of the field's owner archetype. Prefer using <a class="el" href="classrfk_1_1_field.html#a8d398c692a5647118dbba3507153b0e1" title="Set the value corresponding to this field in the provided instance. This method is not safe if you pr...">Field::set</a> for safety if you know the static type of your instance in the calling context.  <a href="classrfk_1_1_field.html#ab9bd9ccf0da0e3fd5e830bba8a696294">More...</a><br /></td></tr>
<tr class="separator:ab9bd9ccf0da0e3fd5e830bba8a696294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51adce67a3c3867e5763c1787616441d"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#a51adce67a3c3867e5763c1787616441d">setUnsafe</a> (void *instance, void const *valuePtr, std::size_t valueSize) const</td></tr>
<tr class="memdesc:a51adce67a3c3867e5763c1787616441d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy valueSize bytes starting from valuePtr into this field's address in instance.  <a href="classrfk_1_1_field.html#a51adce67a3c3867e5763c1787616441d">More...</a><br /></td></tr>
<tr class="separator:a51adce67a3c3867e5763c1787616441d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce7460699dca17a227e4750ce06098f"><td class="memTemplParams" colspan="2">template&lt;typename InstanceType , typename  = std::enable_if_t&lt;is_value_v&lt;InstanceType&gt; &amp;&amp; internal::IsAdjustableInstanceValue&lt;InstanceType&gt;&gt;&gt; </td></tr>
<tr class="memitem:a9ce7460699dca17a227e4750ce06098f"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD void *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#a9ce7460699dca17a227e4750ce06098f">getPtr</a> (InstanceType &amp;instance) const</td></tr>
<tr class="memdesc:a9ce7460699dca17a227e4750ce06098f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to this field in the provided instance.  <a href="classrfk_1_1_field.html#a9ce7460699dca17a227e4750ce06098f">More...</a><br /></td></tr>
<tr class="separator:a9ce7460699dca17a227e4750ce06098f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d74e50b768369ffc4bb6659c76fb486"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#a4d74e50b768369ffc4bb6659c76fb486">getPtrUnsafe</a> (void *instance) const</td></tr>
<tr class="memdesc:a4d74e50b768369ffc4bb6659c76fb486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to this field in the provided instance. This method DOES NOT perform any pointer adjustment on the provided instance so it is unsafe if instance is not a valid pointer to an object of the field's owner archetype. Prefer using <a class="el" href="classrfk_1_1_field.html#a9ce7460699dca17a227e4750ce06098f" title="Get a pointer to this field in the provided instance.">Field::getPtr</a> for safety if you know the static type of your instance in the calling context.  <a href="classrfk_1_1_field.html#a4d74e50b768369ffc4bb6659c76fb486">More...</a><br /></td></tr>
<tr class="separator:a4d74e50b768369ffc4bb6659c76fb486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84177f52c67c28321ccee224ef64c1d"><td class="memTemplParams" colspan="2">template&lt;typename InstanceType , typename  = std::enable_if_t&lt;is_value_v&lt;InstanceType&gt; &amp;&amp; internal::IsAdjustableInstanceValue&lt;InstanceType&gt;&gt;&gt; </td></tr>
<tr class="memitem:ac84177f52c67c28321ccee224ef64c1d"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD void const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#ac84177f52c67c28321ccee224ef64c1d">getConstPtr</a> (InstanceType const &amp;instance) const</td></tr>
<tr class="memdesc:ac84177f52c67c28321ccee224ef64c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to this field in the provided instance.  <a href="classrfk_1_1_field.html#ac84177f52c67c28321ccee224ef64c1d">More...</a><br /></td></tr>
<tr class="separator:ac84177f52c67c28321ccee224ef64c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f103e44b30187aad043a58d6e70893"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API void const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#ac7f103e44b30187aad043a58d6e70893">getConstPtrUnsafe</a> (void const *instance) const noexcept</td></tr>
<tr class="memdesc:ac7f103e44b30187aad043a58d6e70893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to this field in the provided instance. This method DOES NOT perform any pointer adjustment on the provided instance so it is unsafe if instance is not a valid pointer to an object of the field's owner archetype. Prefer using <a class="el" href="classrfk_1_1_field.html#ac84177f52c67c28321ccee224ef64c1d" title="Get a const pointer to this field in the provided instance.">Field::getConstPtr</a> for safety if you know the static type of your instance in the calling context.  <a href="classrfk_1_1_field.html#ac7f103e44b30187aad043a58d6e70893">More...</a><br /></td></tr>
<tr class="separator:ac7f103e44b30187aad043a58d6e70893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fd5d3074e818d73d2f458caeec78ae"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field.html#ad2fd5d3074e818d73d2f458caeec78ae">getMemoryOffset</a> () const noexcept</td></tr>
<tr class="memdesc:ad2fd5d3074e818d73d2f458caeec78ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the memory offset of this field in an instance of its owner class (<a class="el" href="classrfk_1_1_field_base.html#aa784130ce76323e20e7585b8bbdeab80" title="Get the struct owning this field.">Field::getOwner()</a>).  <a href="classrfk_1_1_field.html#ad2fd5d3074e818d73d2f458caeec78ae">More...</a><br /></td></tr>
<tr class="separator:ad2fd5d3074e818d73d2f458caeec78ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrfk_1_1_field_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrfk_1_1_field_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrfk_1_1_field_base.html">rfk::FieldBase</a></td></tr>
<tr class="memitem:a7c8655b2b7f0aba9a97dff62977c46d1 inherit pub_methods_classrfk_1_1_field_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API EAccessSpecifier&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field_base.html#a7c8655b2b7f0aba9a97dff62977c46d1">getAccess</a> () const noexcept</td></tr>
<tr class="memdesc:a7c8655b2b7f0aba9a97dff62977c46d1 inherit pub_methods_classrfk_1_1_field_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the access specifier of this field in its owner struct/class.  <a href="classrfk_1_1_field_base.html#a7c8655b2b7f0aba9a97dff62977c46d1">More...</a><br /></td></tr>
<tr class="separator:a7c8655b2b7f0aba9a97dff62977c46d1 inherit pub_methods_classrfk_1_1_field_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5d0717b1db813036cbacc0a421660e inherit pub_methods_classrfk_1_1_field_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field_base.html#ace5d0717b1db813036cbacc0a421660e">isStatic</a> () const noexcept</td></tr>
<tr class="memdesc:ace5d0717b1db813036cbacc0a421660e inherit pub_methods_classrfk_1_1_field_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this field is static or not. If the field is static, it can safely be cast to <a class="el" href="classrfk_1_1_static_field.html">StaticField</a>.  <a href="classrfk_1_1_field_base.html#ace5d0717b1db813036cbacc0a421660e">More...</a><br /></td></tr>
<tr class="separator:ace5d0717b1db813036cbacc0a421660e inherit pub_methods_classrfk_1_1_field_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d73530a99d8ed65056a1447620dccf3 inherit pub_methods_classrfk_1_1_field_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field_base.html#a6d73530a99d8ed65056a1447620dccf3">isMutable</a> () const noexcept</td></tr>
<tr class="memdesc:a6d73530a99d8ed65056a1447620dccf3 inherit pub_methods_classrfk_1_1_field_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether this field is mutable or not.  <a href="classrfk_1_1_field_base.html#a6d73530a99d8ed65056a1447620dccf3">More...</a><br /></td></tr>
<tr class="separator:a6d73530a99d8ed65056a1447620dccf3 inherit pub_methods_classrfk_1_1_field_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15985bd234a0d4214eec8707ca90ce4 inherit pub_methods_classrfk_1_1_field_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="namespacerfk.html#a4e4ebc12533da5542afa59de6d305a7a">EFieldFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field_base.html#ab15985bd234a0d4214eec8707ca90ce4">getFlags</a> () const noexcept</td></tr>
<tr class="memdesc:ab15985bd234a0d4214eec8707ca90ce4 inherit pub_methods_classrfk_1_1_field_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flags qualifying this field.  <a href="classrfk_1_1_field_base.html#ab15985bd234a0d4214eec8707ca90ce4">More...</a><br /></td></tr>
<tr class="separator:ab15985bd234a0d4214eec8707ca90ce4 inherit pub_methods_classrfk_1_1_field_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa784130ce76323e20e7585b8bbdeab80 inherit pub_methods_classrfk_1_1_field_base"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_struct.html">Struct</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_field_base.html#aa784130ce76323e20e7585b8bbdeab80">getOwner</a> () const noexcept</td></tr>
<tr class="memdesc:aa784130ce76323e20e7585b8bbdeab80 inherit pub_methods_classrfk_1_1_field_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the struct owning this field.  <a href="classrfk_1_1_field_base.html#aa784130ce76323e20e7585b8bbdeab80">More...</a><br /></td></tr>
<tr class="separator:aa784130ce76323e20e7585b8bbdeab80 inherit pub_methods_classrfk_1_1_field_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrfk_1_1_variable_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrfk_1_1_variable_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrfk_1_1_variable_base.html">rfk::VariableBase</a></td></tr>
<tr class="memitem:a431185143104fd81010bba9bc1b23bf4 inherit pub_methods_classrfk_1_1_variable_base"><td class="memItemLeft" align="right" valign="top">REFUREKU_API <a class="el" href="classrfk_1_1_type.html">Type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_variable_base.html#a431185143104fd81010bba9bc1b23bf4">getType</a> () const noexcept</td></tr>
<tr class="memdesc:a431185143104fd81010bba9bc1b23bf4 inherit pub_methods_classrfk_1_1_variable_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of this variable.  <a href="classrfk_1_1_variable_base.html#a431185143104fd81010bba9bc1b23bf4">More...</a><br /></td></tr>
<tr class="separator:a431185143104fd81010bba9bc1b23bf4 inherit pub_methods_classrfk_1_1_variable_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classrfk_1_1_entity"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classrfk_1_1_entity')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classrfk_1_1_entity.html">rfk::Entity</a></td></tr>
<tr class="memitem:a092dbecc208629377670a6afc05af06d inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a092dbecc208629377670a6afc05af06d" name="a092dbecc208629377670a6afc05af06d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Entity</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;)=delete</td></tr>
<tr class="separator:a092dbecc208629377670a6afc05af06d inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b78b5d1f76408794f38bf0f8e7310b1 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a0b78b5d1f76408794f38bf0f8e7310b1">getPropertyAt</a> (std::size_t propertyIndex) const noexcept</td></tr>
<tr class="memdesc:a0b78b5d1f76408794f38bf0f8e7310b1 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the property at the given index. If propertyIndex is greater or equal to the properties count, the behaviour is undefined.  <a href="classrfk_1_1_entity.html#a0b78b5d1f76408794f38bf0f8e7310b1">More...</a><br /></td></tr>
<tr class="separator:a0b78b5d1f76408794f38bf0f8e7310b1 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="memTemplParams" colspan="2">template&lt;typename PropertyType , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;Property, PropertyType&gt; &amp;&amp; !std::is_same_v&lt;PropertyType, Property&gt;&gt;&gt; </td></tr>
<tr class="memitem:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD PropertyType const *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a05d7085bf7604499b2240d527fced26e">getProperty</a> (bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a property of a given type from this entity.  <a href="classrfk_1_1_entity.html#a05d7085bf7604499b2240d527fced26e">More...</a><br /></td></tr>
<tr class="separator:a05d7085bf7604499b2240d527fced26e inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181a40d213920fc16895795829cdb2cf inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a181a40d213920fc16895795829cdb2cf">getProperty</a> (<a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;archetype, bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:a181a40d213920fc16895795829cdb2cf inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first property matching with the provided archetype.  <a href="classrfk_1_1_entity.html#a181a40d213920fc16895795829cdb2cf">More...</a><br /></td></tr>
<tr class="separator:a181a40d213920fc16895795829cdb2cf inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f771df5126a64199aa8de1a4c31f08b inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a2f771df5126a64199aa8de1a4c31f08b">getPropertyByName</a> (char const *name) const noexcept</td></tr>
<tr class="memdesc:a2f771df5126a64199aa8de1a4c31f08b inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the first property named with the provided name.  <a href="classrfk_1_1_entity.html#a2f771df5126a64199aa8de1a4c31f08b">More...</a><br /></td></tr>
<tr class="separator:a2f771df5126a64199aa8de1a4c31f08b inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55b766a0ff8bcbbd3fa5da08bf48414 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_property.html">Property</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#ac55b766a0ff8bcbbd3fa5da08bf48414">getPropertyByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:ac55b766a0ff8bcbbd3fa5da08bf48414 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a property matching with a predicate.  <a href="classrfk_1_1_entity.html#ac55b766a0ff8bcbbd3fa5da08bf48414">More...</a><br /></td></tr>
<tr class="separator:ac55b766a0ff8bcbbd3fa5da08bf48414 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="memTemplParams" colspan="2">template&lt;typename PropertyType , typename  = std::enable_if_t&lt;std::is_base_of_v&lt;Property, PropertyType&gt; &amp;&amp; !std::is_same_v&lt;PropertyType, Property&gt;&gt;&gt; </td></tr>
<tr class="memitem:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; PropertyType const * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a7dd90b03c80098a53899794995e436b4">getProperties</a> (bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties matching with the provided archetype. If PropertyType uses multiple inheritance, its first inherited type must be <a class="el" href="classrfk_1_1_property.html" title="Base class to inherit from to define new properties.">rfk::Property</a> or derived.  <a href="classrfk_1_1_entity.html#a7dd90b03c80098a53899794995e436b4">More...</a><br /></td></tr>
<tr class="separator:a7dd90b03c80098a53899794995e436b4 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c329db7cd25c27f7f8840bfef57344 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#aa6c329db7cd25c27f7f8840bfef57344">getProperties</a> (<a class="el" href="classrfk_1_1_struct.html">Struct</a> const &amp;archetype, bool isChildClassValid=true) const noexcept</td></tr>
<tr class="memdesc:aa6c329db7cd25c27f7f8840bfef57344 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties matching with the provided archetype.  <a href="classrfk_1_1_entity.html#aa6c329db7cd25c27f7f8840bfef57344">More...</a><br /></td></tr>
<tr class="separator:aa6c329db7cd25c27f7f8840bfef57344 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b90791d4b32b69537b21744908961cf inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a3b90791d4b32b69537b21744908961cf">getPropertiesByName</a> (char const *name) const noexcept</td></tr>
<tr class="memdesc:a3b90791d4b32b69537b21744908961cf inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties named with the provided name.  <a href="classrfk_1_1_entity.html#a3b90791d4b32b69537b21744908961cf">More...</a><br /></td></tr>
<tr class="separator:a3b90791d4b32b69537b21744908961cf inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89aa815ce0d56d8d48f780bec404dbac inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_vector.html">Vector</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> const * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a89aa815ce0d56d8d48f780bec404dbac">getPropertiesByPredicate</a> (<a class="el" href="namespacerfk.html#a4c980dac02221ca3abbd01cb8f98c2de">Predicate</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> &gt; predicate, void *userData) const</td></tr>
<tr class="memdesc:a89aa815ce0d56d8d48f780bec404dbac inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve all properties matching with a predicate in this entity.  <a href="classrfk_1_1_entity.html#a89aa815ce0d56d8d48f780bec404dbac">More...</a><br /></td></tr>
<tr class="separator:a89aa815ce0d56d8d48f780bec404dbac inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3bc60196aba4e5c1ae66817a0f9f8c inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#afb3bc60196aba4e5c1ae66817a0f9f8c">getPropertiesCount</a> () const noexcept</td></tr>
<tr class="memdesc:afb3bc60196aba4e5c1ae66817a0f9f8c inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of properties attached to this entity.  <a href="classrfk_1_1_entity.html#afb3bc60196aba4e5c1ae66817a0f9f8c">More...</a><br /></td></tr>
<tr class="separator:afb3bc60196aba4e5c1ae66817a0f9f8c inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6b2baecc7c1c3a063ba12950c948ae inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a3b6b2baecc7c1c3a063ba12950c948ae">foreachProperty</a> (<a class="el" href="namespacerfk.html#aa71b489feb1ea31e5077d0807dc11535">Visitor</a>&lt; <a class="el" href="classrfk_1_1_property.html">Property</a> &gt; visitor, void *userData) const</td></tr>
<tr class="memdesc:a3b6b2baecc7c1c3a063ba12950c948ae inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the given visitor on all properties attached to this entity.  <a href="classrfk_1_1_entity.html#a3b6b2baecc7c1c3a063ba12950c948ae">More...</a><br /></td></tr>
<tr class="separator:a3b6b2baecc7c1c3a063ba12950c948ae inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349024a085b2807ade1f7dc12e47a15b inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a349024a085b2807ade1f7dc12e47a15b">getName</a> () const noexcept</td></tr>
<tr class="memdesc:a349024a085b2807ade1f7dc12e47a15b inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the entity.  <a href="classrfk_1_1_entity.html#a349024a085b2807ade1f7dc12e47a15b">More...</a><br /></td></tr>
<tr class="separator:a349024a085b2807ade1f7dc12e47a15b inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fca0dc8eed33bf14abb616fc99b9fcd inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a9fca0dc8eed33bf14abb616fc99b9fcd">hasSameName</a> (char const *name) const noexcept</td></tr>
<tr class="memdesc:a9fca0dc8eed33bf14abb616fc99b9fcd inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that this entity has the same name as the provided string.  <a href="classrfk_1_1_entity.html#a9fca0dc8eed33bf14abb616fc99b9fcd">More...</a><br /></td></tr>
<tr class="separator:a9fca0dc8eed33bf14abb616fc99b9fcd inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88488c7a3f458b81dda29f5ba664e6c inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#ac88488c7a3f458b81dda29f5ba664e6c">getId</a> () const noexcept</td></tr>
<tr class="memdesc:ac88488c7a3f458b81dda29f5ba664e6c inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the program-unique id of the entity.  <a href="classrfk_1_1_entity.html#ac88488c7a3f458b81dda29f5ba664e6c">More...</a><br /></td></tr>
<tr class="separator:ac88488c7a3f458b81dda29f5ba664e6c inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4a1f4ec5fa498f834a1c1da7553afe inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="namespacerfk.html#af958ab385009c79cc3a27e9b3183c5d5">EEntityKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#afd4a1f4ec5fa498f834a1c1da7553afe">getKind</a> () const noexcept</td></tr>
<tr class="memdesc:afd4a1f4ec5fa498f834a1c1da7553afe inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the kind of the entity. Knowing the kind allows to safely cast to child classes. Check the EEntityKind documentation for more information.  <a href="classrfk_1_1_entity.html#afd4a1f4ec5fa498f834a1c1da7553afe">More...</a><br /></td></tr>
<tr class="separator:afd4a1f4ec5fa498f834a1c1da7553afe inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640f4b0c6a592184803c413258961511 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">RFK_NODISCARD REFUREKU_API <a class="el" href="classrfk_1_1_entity.html">Entity</a> const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a640f4b0c6a592184803c413258961511">getOuterEntity</a> () const noexcept</td></tr>
<tr class="memdesc:a640f4b0c6a592184803c413258961511 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the outer entity of the entity. It basically corresponds to the entity this entity was declared in from a source-code point of view. A nullptr outer entity means the entity was declared at file level.  <a href="classrfk_1_1_entity.html#a640f4b0c6a592184803c413258961511">More...</a><br /></td></tr>
<tr class="separator:a640f4b0c6a592184803c413258961511 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4089b9c11fea52e987d5975f1d8455 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#abf4089b9c11fea52e987d5975f1d8455">addProperty</a> (<a class="el" href="classrfk_1_1_property.html">Property</a> const &amp;property) noexcept</td></tr>
<tr class="memdesc:abf4089b9c11fea52e987d5975f1d8455 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a property to this entity.  <a href="classrfk_1_1_entity.html#abf4089b9c11fea52e987d5975f1d8455">More...</a><br /></td></tr>
<tr class="separator:abf4089b9c11fea52e987d5975f1d8455 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1768c2e434411991a5badc9d38956d96 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#a1768c2e434411991a5badc9d38956d96">setOuterEntity</a> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const *outerEntity) noexcept</td></tr>
<tr class="memdesc:a1768c2e434411991a5badc9d38956d96 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setter for the field _outerEntity.  <a href="classrfk_1_1_entity.html#a1768c2e434411991a5badc9d38956d96">More...</a><br /></td></tr>
<tr class="separator:a1768c2e434411991a5badc9d38956d96 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48595d14a255dd9d76f1f6c14acb0a0 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top">REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_entity.html#ac48595d14a255dd9d76f1f6c14acb0a0">setPropertiesCapacity</a> (std::size_t capacity) noexcept</td></tr>
<tr class="memdesc:ac48595d14a255dd9d76f1f6c14acb0a0 inherit pub_methods_classrfk_1_1_entity"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of properties for this entity. Useful to avoid reallocations when adding a lot of properties. If the number of properties is already &gt;= to the provided capacity, this method has no effect.  <a href="classrfk_1_1_entity.html#ac48595d14a255dd9d76f1f6c14acb0a0">More...</a><br /></td></tr>
<tr class="separator:ac48595d14a255dd9d76f1f6c14acb0a0 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b62164e710f9a5600d827932f8ef98b inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a6b62164e710f9a5600d827932f8ef98b" name="a6b62164e710f9a5600d827932f8ef98b"></a>
<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;)=delete</td></tr>
<tr class="separator:a6b62164e710f9a5600d827932f8ef98b inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a0f7549543c0d8102c99b8befef70d inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="ab5a0f7549543c0d8102c99b8befef70d" name="ab5a0f7549543c0d8102c99b8befef70d"></a>
<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:ab5a0f7549543c0d8102c99b8befef70d inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58eb57c553e9773b2b05a5f163561e72 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a58eb57c553e9773b2b05a5f163561e72" name="a58eb57c553e9773b2b05a5f163561e72"></a>
RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;other) const noexcept</td></tr>
<tr class="separator:a58eb57c553e9773b2b05a5f163561e72 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96260f434f193f8f2675ba3de3bc8e05 inherit pub_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a96260f434f193f8f2675ba3de3bc8e05" name="a96260f434f193f8f2675ba3de3bc8e05"></a>
RFK_NODISCARD REFUREKU_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> const &amp;other) const noexcept</td></tr>
<tr class="separator:a96260f434f193f8f2675ba3de3bc8e05 inherit pub_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classrfk_1_1_field_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrfk_1_1_field_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrfk_1_1_field_base.html">rfk::FieldBase</a></td></tr>
<tr class="memitem:a43ab91629c41187e33a3c5b0df47bb45 inherit pro_methods_classrfk_1_1_field_base"><td class="memItemLeft" align="right" valign="top"><a id="a43ab91629c41187e33a3c5b0df47bb45" name="a43ab91629c41187e33a3c5b0df47bb45"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>FieldBase</b> (FieldBaseImpl *implementation) noexcept</td></tr>
<tr class="separator:a43ab91629c41187e33a3c5b0df47bb45 inherit pro_methods_classrfk_1_1_field_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c77795d53b27c1164f19a46824d11e6 inherit pro_methods_classrfk_1_1_field_base"><td class="memItemLeft" align="right" valign="top"><a id="a3c77795d53b27c1164f19a46824d11e6" name="a3c77795d53b27c1164f19a46824d11e6"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>FieldBase</b> (<a class="el" href="classrfk_1_1_field_base.html">FieldBase</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:a3c77795d53b27c1164f19a46824d11e6 inherit pro_methods_classrfk_1_1_field_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrfk_1_1_variable_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrfk_1_1_variable_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrfk_1_1_variable_base.html">rfk::VariableBase</a></td></tr>
<tr class="memitem:a34537fb5d58fef76400b0cb30ec20c2d inherit pro_methods_classrfk_1_1_variable_base"><td class="memItemLeft" align="right" valign="top"><a id="a34537fb5d58fef76400b0cb30ec20c2d" name="a34537fb5d58fef76400b0cb30ec20c2d"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>VariableBase</b> (VariableBaseImpl *implementation) noexcept</td></tr>
<tr class="separator:a34537fb5d58fef76400b0cb30ec20c2d inherit pro_methods_classrfk_1_1_variable_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b27d63743449a7f90b80897e7e272a7 inherit pro_methods_classrfk_1_1_variable_base"><td class="memItemLeft" align="right" valign="top"><a id="a5b27d63743449a7f90b80897e7e272a7" name="a5b27d63743449a7f90b80897e7e272a7"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>VariableBase</b> (<a class="el" href="classrfk_1_1_variable_base.html">VariableBase</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:a5b27d63743449a7f90b80897e7e272a7 inherit pro_methods_classrfk_1_1_variable_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39cde4d37298d893b8978b035158b88 inherit pro_methods_classrfk_1_1_variable_base"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ab39cde4d37298d893b8978b035158b88 inherit pro_methods_classrfk_1_1_variable_base"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_variable_base.html#ab39cde4d37298d893b8978b035158b88">get</a> (void *ptr) const</td></tr>
<tr class="memdesc:ab39cde4d37298d893b8978b035158b88 inherit pro_methods_classrfk_1_1_variable_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data stored in the provided ptr. This method in not safe if you provide a wrong DataType.  <a href="classrfk_1_1_variable_base.html#ab39cde4d37298d893b8978b035158b88">More...</a><br /></td></tr>
<tr class="separator:ab39cde4d37298d893b8978b035158b88 inherit pro_methods_classrfk_1_1_variable_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9138d28806b4b63fc623aaa1c3bcbb inherit pro_methods_classrfk_1_1_variable_base"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:aaf9138d28806b4b63fc623aaa1c3bcbb inherit pro_methods_classrfk_1_1_variable_base"><td class="memTemplItemLeft" align="right" valign="top">RFK_NODISCARD ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_variable_base.html#aaf9138d28806b4b63fc623aaa1c3bcbb">get</a> (void const *ptr) const</td></tr>
<tr class="memdesc:aaf9138d28806b4b63fc623aaa1c3bcbb inherit pro_methods_classrfk_1_1_variable_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data stored in the provided ptr. This method in not safe if you provide a wrong DataType. Overload of the same method for const pointers.  <a href="classrfk_1_1_variable_base.html#aaf9138d28806b4b63fc623aaa1c3bcbb">More...</a><br /></td></tr>
<tr class="separator:aaf9138d28806b4b63fc623aaa1c3bcbb inherit pro_methods_classrfk_1_1_variable_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f5b2617be52bec76af718760895c11 inherit pro_methods_classrfk_1_1_variable_base"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:ab7f5b2617be52bec76af718760895c11 inherit pro_methods_classrfk_1_1_variable_base"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classrfk_1_1_variable_base.html#ab7f5b2617be52bec76af718760895c11">set</a> (void *ptr, ValueType &amp;&amp;value) const</td></tr>
<tr class="memdesc:ab7f5b2617be52bec76af718760895c11 inherit pro_methods_classrfk_1_1_variable_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the provided pointer content. This method is not safe if you provide a wrong ValueType.  <a href="classrfk_1_1_variable_base.html#ab7f5b2617be52bec76af718760895c11">More...</a><br /></td></tr>
<tr class="separator:ab7f5b2617be52bec76af718760895c11 inherit pro_methods_classrfk_1_1_variable_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8e5124ca1c93940d50ca4fe1811a66 inherit pro_methods_classrfk_1_1_variable_base"><td class="memItemLeft" align="right" valign="top">REFUREKU_INTERNAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_variable_base.html#a2c8e5124ca1c93940d50ca4fe1811a66">set</a> (void *target, void const *source, std::size_t bytesCount) const</td></tr>
<tr class="memdesc:a2c8e5124ca1c93940d50ca4fe1811a66 inherit pro_methods_classrfk_1_1_variable_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy dataSize bytes starting from data into the variable.  <a href="classrfk_1_1_variable_base.html#a2c8e5124ca1c93940d50ca4fe1811a66">More...</a><br /></td></tr>
<tr class="separator:a2c8e5124ca1c93940d50ca4fe1811a66 inherit pro_methods_classrfk_1_1_variable_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classrfk_1_1_entity"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classrfk_1_1_entity')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classrfk_1_1_entity.html">rfk::Entity</a></td></tr>
<tr class="memitem:a502d0895419cf5420ddfffb2c9743fe2 inherit pro_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a502d0895419cf5420ddfffb2c9743fe2" name="a502d0895419cf5420ddfffb2c9743fe2"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Entity</b> (<a class="el" href="classrfk_1_1_entity.html">Entity</a> &amp;&amp;) noexcept</td></tr>
<tr class="separator:a502d0895419cf5420ddfffb2c9743fe2 inherit pro_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b757749f74869d1f5f7b8257cd40591 inherit pro_methods_classrfk_1_1_entity"><td class="memItemLeft" align="right" valign="top"><a id="a4b757749f74869d1f5f7b8257cd40591" name="a4b757749f74869d1f5f7b8257cd40591"></a>
REFUREKU_INTERNAL&#160;</td><td class="memItemRight" valign="bottom"><b>Entity</b> (EntityImpl *implementation) noexcept</td></tr>
<tr class="separator:a4b757749f74869d1f5f7b8257cd40591 inherit pro_methods_classrfk_1_1_entity"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classrfk_1_1_variable_base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classrfk_1_1_variable_base')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classrfk_1_1_variable_base.html">rfk::VariableBase</a></td></tr>
<tr class="memitem:a01911b5c493fdc86cbc29656f802043b inherit pro_static_methods_classrfk_1_1_variable_base"><td class="memItemLeft" align="right" valign="top">RFK_NORETURN static REFUREKU_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classrfk_1_1_variable_base.html#a01911b5c493fdc86cbc29656f802043b">throwConstViolationException</a> (char const *message)</td></tr>
<tr class="memdesc:a01911b5c493fdc86cbc29656f802043b inherit pro_static_methods_classrfk_1_1_variable_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a <a class="el" href="classrfk_1_1_const_violation.html">ConstViolation</a> exception with the specified message. /!\ This method is called from template methods so it must be exported.  <a href="classrfk_1_1_variable_base.html#a01911b5c493fdc86cbc29656f802043b">More...</a><br /></td></tr>
<tr class="separator:a01911b5c493fdc86cbc29656f802043b inherit pro_static_methods_classrfk_1_1_variable_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classrfk_1_1_variable_base"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classrfk_1_1_variable_base')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classrfk_1_1_variable_base.html">rfk::VariableBase</a></td></tr>
<tr class="memitem:ac812e7801abbdf25b7414cd1ce0a8724 inherit pro_static_attribs_classrfk_1_1_variable_base"><td class="memTemplParams" colspan="2"><a id="ac812e7801abbdf25b7414cd1ce0a8724" name="ac812e7801abbdf25b7414cd1ce0a8724"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac812e7801abbdf25b7414cd1ce0a8724 inherit pro_static_attribs_classrfk_1_1_variable_base"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_value_v</b> = !std::is_lvalue_reference_v&lt;T&gt; &amp;&amp; !std::is_rvalue_reference_v&lt;T&gt;</td></tr>
<tr class="separator:ac812e7801abbdf25b7414cd1ce0a8724 inherit pro_static_attribs_classrfk_1_1_variable_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a985da6fc03517fb4a67da2f5dd87cb72" name="a985da6fc03517fb4a67da2f5dd87cb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985da6fc03517fb4a67da2f5dd87cb72">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename InstanceType , typename  = std::enable_if_t&lt;is_value_v&lt;InstanceType&gt; &amp;&amp; internal::IsAdjustableInstanceValue&lt;InstanceType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD ValueType rfk::Field::get </td>
          <td>(</td>
          <td class="paramtype">InstanceType &amp;&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value corresponding to this field in the provided instance. This method in not safe if you provide a wrong ValueType. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td><a class="el" href="classrfk_1_1_type.html">Type</a> to retrieve from the field. If ValueType is an rvalue reference, the field value is moved into the return value (so the field value is no longer safe to use). If ValueType is an lvalue reference, return a reference to the field. If ValueType is a value type, the value is copied. If it is a class, ValueType must be copy-constructible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance we retrieve the value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_const_violation.html">ConstViolation</a></td><td>if:<ul>
<li>the field is const and ValueType is an RValue type (can't move a const field content);</li>
<li>the field is const and ValueType is a non-const reference; </li>
</ul>
</td></tr>
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_invalid_archetype.html">InvalidArchetype</a></td><td>if the field can't be accessed from the provided instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The queried value in the instance. </dd></dl>

</div>
</div>
<a id="ac84177f52c67c28321ccee224ef64c1d" name="ac84177f52c67c28321ccee224ef64c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84177f52c67c28321ccee224ef64c1d">&#9670;&nbsp;</a></span>getConstPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InstanceType , typename  = std::enable_if_t&lt;is_value_v&lt;InstanceType&gt; &amp;&amp; internal::IsAdjustableInstanceValue&lt;InstanceType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD void const  * rfk::Field::getConstPtr </td>
          <td>(</td>
          <td class="paramtype">InstanceType const &amp;&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a const pointer to this field in the provided instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance we get the field from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const pointer to this field in the provided instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_invalid_archetype.html">InvalidArchetype</a></td><td>if the field can't be accessed from the provided instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7f103e44b30187aad043a58d6e70893" name="ac7f103e44b30187aad043a58d6e70893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f103e44b30187aad043a58d6e70893">&#9670;&nbsp;</a></span>getConstPtrUnsafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API void const  * rfk::Field::getConstPtrUnsafe </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const pointer to this field in the provided instance. This method DOES NOT perform any pointer adjustment on the provided instance so it is unsafe if instance is not a valid pointer to an object of the field's owner archetype. Prefer using <a class="el" href="classrfk_1_1_field.html#ac84177f52c67c28321ccee224ef64c1d" title="Get a const pointer to this field in the provided instance.">Field::getConstPtr</a> for safety if you know the static type of your instance in the calling context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance we get the field from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const pointer to this field in the provided instance. </dd></dl>

</div>
</div>
<a id="ad2fd5d3074e818d73d2f458caeec78ae" name="ad2fd5d3074e818d73d2f458caeec78ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fd5d3074e818d73d2f458caeec78ae">&#9670;&nbsp;</a></span>getMemoryOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API std::size_t rfk::Field::getMemoryOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the memory offset of this field in an instance of its owner class (<a class="el" href="classrfk_1_1_field_base.html#aa784130ce76323e20e7585b8bbdeab80" title="Get the struct owning this field.">Field::getOwner()</a>). </p>
<dl class="section return"><dt>Returns</dt><dd>The memory offset in bytes. </dd></dl>

</div>
</div>
<a id="a9ce7460699dca17a227e4750ce06098f" name="a9ce7460699dca17a227e4750ce06098f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce7460699dca17a227e4750ce06098f">&#9670;&nbsp;</a></span>getPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InstanceType , typename  = std::enable_if_t&lt;is_value_v&lt;InstanceType&gt; &amp;&amp; internal::IsAdjustableInstanceValue&lt;InstanceType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD void * rfk::Field::getPtr </td>
          <td>(</td>
          <td class="paramtype">InstanceType &amp;&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to this field in the provided instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance we get the field from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to this field in the provided instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_const_violation.html">ConstViolation</a></td><td>if the field is actually const. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_invalid_archetype.html">InvalidArchetype</a></td><td>if the field can't be accessed from the provided instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d74e50b768369ffc4bb6659c76fb486" name="a4d74e50b768369ffc4bb6659c76fb486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d74e50b768369ffc4bb6659c76fb486">&#9670;&nbsp;</a></span>getPtrUnsafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD REFUREKU_API void * rfk::Field::getPtrUnsafe </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to this field in the provided instance. This method DOES NOT perform any pointer adjustment on the provided instance so it is unsafe if instance is not a valid pointer to an object of the field's owner archetype. Prefer using <a class="el" href="classrfk_1_1_field.html#a9ce7460699dca17a227e4750ce06098f" title="Get a pointer to this field in the provided instance.">Field::getPtr</a> for safety if you know the static type of your instance in the calling context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance we get the field from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to this field in the provided instance.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_const_violation.html">ConstViolation</a></td><td>if the field is actually const. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_invalid_archetype.html">InvalidArchetype</a></td><td>if the field can't be accessed from the provided instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a554728e8a99550c5d91de7861e08015d" name="a554728e8a99550c5d91de7861e08015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a554728e8a99550c5d91de7861e08015d">&#9670;&nbsp;</a></span>getUnsafe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD ValueType rfk::Field::getUnsafe </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value corresponding to this field in the provided instance. This method in not safe if you provide a wrong ValueType. This method DOES NOT perform any pointer adjustment on the provided instance so it is unsafe if instance is not a valid pointer to an object of the field's owner archetype. Prefer using <a class="el" href="classrfk_1_1_field.html#a985da6fc03517fb4a67da2f5dd87cb72" title="Get the value corresponding to this field in the provided instance. This method in not safe if you pr...">Field::get</a> for safety if you know the static type of your instance in the calling context. </p>
<dl class="section note"><dt>Note</dt><dd>Since this method doesn't perform any pointer adjustment, it is slightly faster than <a class="el" href="classrfk_1_1_field.html#a985da6fc03517fb4a67da2f5dd87cb72" title="Get the value corresponding to this field in the provided instance. This method in not safe if you pr...">Field::get</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td><a class="el" href="classrfk_1_1_type.html">Type</a> to retrieve from the field. If ValueType is an rvalue reference, the field value is moved into the return value (so the field value is no longer safe to use). If ValueType is an lvalue reference, return a reference to the field. If ValueType is a value type, the value is copied. If it is a class, ValueType must be copy-constructible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance we retrieve the value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_const_violation.html">ConstViolation</a></td><td>if:<ul>
<li>the field is const and ValueType is an RValue type (can't move a const field content);</li>
<li>the field is const and ValueType is a non-const reference;</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The queried value in the instance. </dd></dl>

</div>
</div>
<a id="af68f57e7fd571a34d378941f68aee237" name="af68f57e7fd571a34d378941f68aee237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af68f57e7fd571a34d378941f68aee237">&#9670;&nbsp;</a></span>getUnsafe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RFK_NODISCARD ValueType rfk::Field::getUnsafe </td>
          <td>(</td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value corresponding to this field in the provided instance. This method in not safe if you provide a wrong ValueType. This method DOES NOT perform any pointer adjustment on the provided instance so it is unsafe if instance is not a valid pointer to an object of the field's owner archetype. Prefer using <a class="el" href="classrfk_1_1_field.html#a985da6fc03517fb4a67da2f5dd87cb72" title="Get the value corresponding to this field in the provided instance. This method in not safe if you pr...">Field::get</a> for safety if you know the static type of your instance in the calling context. </p>
<dl class="section note"><dt>Note</dt><dd>This is only an overload of the same method with a const instance. Since this method doesn't perform any pointer adjustment, it is slightly faster than <a class="el" href="classrfk_1_1_field.html#a985da6fc03517fb4a67da2f5dd87cb72" title="Get the value corresponding to this field in the provided instance. This method in not safe if you pr...">Field::get</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td><a class="el" href="classrfk_1_1_type.html">Type</a> to retrieve from the field. If ValueType is an rvalue reference, the field value is moved into the return value (so the field value is no longer safe to use). If ValueType is an lvalue reference, return a reference to the field. If ValueType is a value type, the value is copied. If it is a class, ValueType must be copy-constructible.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance we retrieve the value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_const_violation.html">ConstViolation</a></td><td>if:<ul>
<li>the field is const and ValueType is an RValue type (can't move a const field content);</li>
<li>the field is const and ValueType is a non-const reference;</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The queried value in the instance. </dd></dl>

</div>
</div>
<a id="a8d398c692a5647118dbba3507153b0e1" name="a8d398c692a5647118dbba3507153b0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d398c692a5647118dbba3507153b0e1">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename InstanceType , typename  = std::enable_if_t&lt;is_value_v&lt;InstanceType&gt; &amp;&amp; internal::IsAdjustableInstanceValue&lt;InstanceType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rfk::Field::set </td>
          <td>(</td>
          <td class="paramtype">InstanceType &amp;&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value corresponding to this field in the provided instance. This method is not safe if you provide a wrong ValueType. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td><a class="el" href="classrfk_1_1_type.html">Type</a> to write into the field. If ValueType is an rvalue reference, the value is forwarded into the instance. If ValueType is an lvalue reference, the value is copied into the instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance we set the value in. </td></tr>
    <tr><td class="paramname">value</td><td>Data to set in the instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_const_violation.html">ConstViolation</a></td><td>if the field is actually const and therefore readonly. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_invalid_archetype.html">InvalidArchetype</a></td><td>if the field can't be accessed from the provided instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1e630ab9c3a6c638fcba1919f143f99" name="aa1e630ab9c3a6c638fcba1919f143f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e630ab9c3a6c638fcba1919f143f99">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InstanceType , typename  = std::enable_if_t&lt;is_value_v&lt;InstanceType&gt; &amp;&amp; internal::IsAdjustableInstanceValue&lt;InstanceType&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rfk::Field::set </td>
          <td>(</td>
          <td class="paramtype">InstanceType &amp;&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>valueSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy valueSize bytes starting from valuePtr into this field's address in instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance we write the bytes in. </td></tr>
    <tr><td class="paramname">valuePtr</td><td>Pointer to the value to copy. </td></tr>
    <tr><td class="paramname">valueSize</td><td>Number of bytes to copy into the field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_const_violation.html">ConstViolation</a></td><td>if the field is actually const and therefore readonly. </td></tr>
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_invalid_archetype.html">InvalidArchetype</a></td><td>if the field can't be accessed from the provided instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9bd9ccf0da0e3fd5e830bba8a696294" name="ab9bd9ccf0da0e3fd5e830bba8a696294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bd9ccf0da0e3fd5e830bba8a696294">&#9670;&nbsp;</a></span>setUnsafe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void rfk::Field::setUnsafe </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value corresponding to this field in the provided instance. This method is not safe if you provide a wrong ValueType. This method DOES NOT perform any pointer adjustment on the provided instance so it is unsafe if instance is not a valid pointer to an object of the field's owner archetype. Prefer using <a class="el" href="classrfk_1_1_field.html#a8d398c692a5647118dbba3507153b0e1" title="Set the value corresponding to this field in the provided instance. This method is not safe if you pr...">Field::set</a> for safety if you know the static type of your instance in the calling context. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td><a class="el" href="classrfk_1_1_type.html">Type</a> to write into the field. If ValueType is an rvalue reference, the value is forwarded into the instance. If ValueType is an lvalue reference, the value is copied into the instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance we set the value in. </td></tr>
    <tr><td class="paramname">value</td><td>Data to set in the instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_const_violation.html">ConstViolation</a></td><td>if the field is actually const and therefore readonly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51adce67a3c3867e5763c1787616441d" name="a51adce67a3c3867e5763c1787616441d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51adce67a3c3867e5763c1787616441d">&#9670;&nbsp;</a></span>setUnsafe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">REFUREKU_API void rfk::Field::setUnsafe </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>valueSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy valueSize bytes starting from valuePtr into this field's address in instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>Instance we write the bytes in. </td></tr>
    <tr><td class="paramname">valuePtr</td><td>Pointer to the value to copy. </td></tr>
    <tr><td class="paramname">valueSize</td><td>Number of bytes to copy into the field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classrfk_1_1_const_violation.html">ConstViolation</a></td><td>if the field is actually const and therefore readonly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Refureku/Library/Include/Public/Refureku/TypeInfo/Variables/<a class="el" href="_field_8h_source.html">Field.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacerfk.html">rfk</a></li><li class="navelem"><a class="el" href="classrfk_1_1_field.html">Field</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
